{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the Pi-Apps documentation page! Pi-Apps is an open-source app store for Raspberry Pi computers, written in 100% bash scripts. If you find the project helpful, please consider leaving a star on our main repository ! Main Repository: https://github.com/Botspot/pi-apps Website: https://pi-apps.io File Storage: https://github.com/Pi-Apps-Coders/files","title":"Home"},{"location":"#home","text":"Welcome to the Pi-Apps documentation page! Pi-Apps is an open-source app store for Raspberry Pi computers, written in 100% bash scripts. If you find the project helpful, please consider leaving a star on our main repository ! Main Repository: https://github.com/Botspot/pi-apps Website: https://pi-apps.io File Storage: https://github.com/Pi-Apps-Coders/files","title":"Home"},{"location":"apps-list/","text":"Apps List Appearance Color Emoji font ARM32/ARM64 Installs two fonts to display all emojis in the Unicode Emoji 13.0. This installs Noto Color Emoji font. To test if it works, go to: https://tmh.conlang.org/emoji-language/all-emoji.html Conky https://github.com/Botspot/rpi_conky ARM32/ARM64 Monitors CPU, RAM, disk usage, and more. This sits on your desktop, refreshing once a second, with pretty graphs showing you all you need to know. To run: it should autostart on boot. To run in a terminal: conky Conky Rings https://github.com/Botspot/rpi_conky/tree/master/conky_rings - phoenixbyrd for the files ryanfortner for the scripts Botspot for coloring the theme ARM32/ARM64 Animated gauges and graphs of your system, on your desktop. Displays system uptime, core-specific CPU usage, CPU speed, CPU temperature, top 5 processes by CPU usage, storage usage for boot and root partitions, RAM usage, SWAP usage, top 5 processes by RAM usage, and describes the current Linux environment. Cool Retro Term https://github.com/Swordfish90/cool-retro-term ARM32/ARM64 Simulates an old CRT terminal. This is fully hardware accelerated as long as your Fake KMS GPU driver is enabled. Yes, it's a usable pi@raspberrypi terminal emulator. To run: Menu -> System Tools -> Cool Retro Term To run in terminal: ~/cool-retro-term/cool-retro-term eDEX-UI https://github.com/Botspot/eDEX-UI-RPi ARM32/ARM64 Futuristic hacker terminal Inspired from Hollywood, this terminal is beautiful to look at and will impress your friends. It's a fully-functional bash terminal, system monitor, file manager, and on-screen keyboard, all in one fullscreen window. Oh, and it has sound effects. To run: Menu -> System Tools -> eDEX-UI 2.2.7. This new version loads in about 10 seconds! (instead of 2 minutes like Novaspirit's old version) To exit eDEX-UI, press Alt+F4, or run this command in the terminal: exit Change settings with Ctrl+Shift+S. View all keyboard shortcuts with Ctrl+Shift+K. Novaspirit Tech made an excellent walkthrough video a while ago: https://www.youtube.com/watch?v=DJOAmYlDQuM Geany Dark Mode https://github.com/codebrainz/geany-themes - Botspot. Oh yeah. ARM32/ARM64 Proper appearance theme for the Geany text editor. Geany's default color scheme looks horrible. Fortunately, this app will make it look good. By default, this will apply the \"spyder-dark\" theme, (Botspot's favorite!), but it will also install many other themes to try out as well. To switch themes in Geany: View -> Change Color Scheme. Libreoffice MS theme https://github.com/Botspot/libreoffice-ms-theme - Botspot made this script and theme. ARM32/ARM64 Make Libreoffice to look like Microsoft office - icon theme and tabbed interface. The icon theme was obtained from here: https://www.deviantart.com/charliecnr/art/Office-2013-theme-for-LibreOffice-512127527 And the tabbed interface is a hidden feature within Libreoffice. Currently, the tabbed interface works for Calc, Impress, and Writer. Base and Math don't support it, and it doesn't display correctly on Draw for some reason. Lightpad https://github.com/libredeb/lightpad - Installation Script Made By RPICoder App Added To Pi-Apps by RPICoder ARM32/ARM64 LightPad is a lightweight, simple and powerful application launcher. To run: Menu -> Accessories -> Lightpad To run in a terminal: com.github.libredeb.lightpad Mac OS Theme https://github.com/techcoder20/MacOSBigSurThemeConverter - App Made By And Added To Pi-Apps By RPI Coder ARM32 ONLY Realistic Light/Dark Mac OS Big Sur appearance theme. Uses XFCE desktop. This is a bash script that will make your plain Raspberry Pi OS LXDE desktop look similar to MacOSBigSur. You can switch between light and dark themes using the themeconverter. To run: Menu -> Accessories -> ThemeConverter To run in a terminal: themeconverter Uninstalling this app should restore all of your original theme configuration. If something breaks due to this theme, please report it. Oomox Theme Designer https://github.com/themix-project/oomox ARM32/ARM64 A tool to customize icons, xrdb and GTK themes. Graphical application for generating different color variations of Oomox (Numix-based) and Materia (ex-Flat-Plat) themes (GTK2, GTK3, Cinnamon, GNOME, Openbox, Xfwm), Archdroid, Gnome-Color, Numix, Papirus and Suru++ icon themes. You can apply your themes in lxappearance. To run: Menu -> Graphics -> Oomox Theme Designer To run in a terminal: oomox-gui Powerline-Shell https://github.com/techcoder20/RPI-PowerlineShell-Installer.git - Installation Script Created By RPICoder Added To Pi Apps By Botspot ARM32/ARM64 A beautiful and useful prompt generator for Bash, ZSH, Fish, and tcsh: -Shows some important details about the git/svn/hg/fossil branch -Changes color if the last command exited with a failure code -If you're too deep into a directory tree, shortens the displayed path with an ellipsis -Shows the current Python virtualenv environment -It's easy to customize and extend. Ulauncher https://ulauncher.io/ - RPiCoder on Discord recommended this. Botspot made the scripts. ARM32/ARM64 All-in-one application launcher, Google search engine, calculator, file manager... This is the best app launcher I've ever seen, though it can be a bit slow when searching. - Botspot Windows 10 Theme https://github.com/Botspot/Windows-10 ARM32/ARM64 Make Raspberry Pi OS look as close to Windows 10 as possible. Installs an icon theme, GTK theme, openbox theme, mouse cursor theme, window shadows, window fading, desktop background and custom panel. Windows Screensavers https://github.com/Botspot/Screensavers - Botspot ARM32 ONLY 14 Windows screensavers that run well on Raspberry Pi. Once installed, you can launch Botspot's Screensavers GUI from: Menu -> Preferences -> Windows Screensavers. To run in terminal: ~/Screensavers/gui Preview a screensaver, change its settings, and enable it to run after a specified duration of inactivity. The screensaver will not start while audio is playing. Note: If you don't have Wine installed, this app will install it for you. In addition to the Windows Screensavers, Botspot's Screensaver GUI also allows convenient installation of GPU-accelerated Xscreensaver, preset to enable the best ones out of 230 screensavers. XSnow https://www.ratrabbit.nl/ratrabbit/xsnow/ - Thanks to Willem Vermin for developing this project. ARM32/ARM64 This turns your desktop wallpaper into an animated winter wonderland! Features falling snowflakes, flying birds, scenery like trees and deer, the moon, Santa, flapping birds, and more. Over time, snow will begin to collect on the top of your windows. To run: Menu -> Games -> xsnow To run in terminal: xsnow Editors Arduino https://www.arduino.cc/en/main/software ARM32/ARM64 Latest version of Arduino IDE. Not outdated like the repository's Arduino IDE. Use this to flash your code to Arduino microprocessors. To run: Menu -> Programming -> Arduino IDE. To run in a terminal: /home/pi/arduino-1.8.13/arduino BlockBench https://github.com/JannisX11/blockbench - JannisX11 (GitHub) for creating the program ryanfortner (GitHub) for writing scripts, and hosting the debs cycool29 (GitHub) for compiling debs ARM32/ARM64 Blockbench is a free, modern model editor for low-poly and boxy models with pixel art textures. Models can be exported into standardized formats, to be shared, rendered, 3D-printed, or used in game engines. There are also multiple dedicated formats for Minecraft Java and Bedrock Edition with format-specific features. BlockPi https://github.com/alienzhangyw/BlockPi - Botspot made the app's install scripts ARM32/ARM64 Create python programs using drag-n-drop blocks A visual programming editor app for Raspberry Pi, built on Google Blockly, made for RPi users or kids to learn coding. To run: Menu -> Programming -> BlockPi To run in a terminal: /opt/BlockPi/blockpi Boxy SVG https://github.com/Botspot/Boxy-SVG-RPi - Shout-out to ItzCutePikachu for figuring out how to remove the annoying \"Boxy SVG will stop working\" pop-up from the javascript. ARM32/ARM64 The best vector graphics image editor for Raspberry Pi. Finally, the full version of Boxy SVG has arrived! This installs the Boxy SVG offline Chrome App onto your existing Chromium Browser. Performance is excellent, and I (Botspot) have been using it on my RPi for for all graphics editing. (Including the Pi-Apps logo!) If you have a problem using Boxy SVG, please report it on Botspot's github page, not to the Boxy SVG website! If there's too many RPi-based bug reports, the Boxy SVG dev may withdraw his permission for it to be on Pi-Apps, and nobody wants that to happen. Note: also see the Inkscape app. Codex https://github.com/jcv8000/Codex ARM32/ARM64 A free note-taking software for programmers and Computer Science students. To run: Menu -> Accessories -> Codex Cura https://community.ultimaker.com/topic/28746-experimental-cura-build-for-raspberry-pi-4-now-available/ ARM32/ARM64 Takes a 3D model and slices it for use in a 3D printer. To run: Menu -> Programming -> Ultimaker Cura To run in a terminal: ~/Cura.AppImage Drawing https://github.com/maoschanz/drawing - Botspot ARM32/ARM64 Simple program used to hand-draw png images. To run: Menu -> Graphics -> Drawing To run in terminal: drawing Note: This serves a different purpose than Microsoft Paint. If you want a Paint-style tool, install Kolourpaint: sudo apt install kolourpaint Eagle CAD http://eagle.autodesk.com/eagle/software-versions/1 - Botspot made this app. ARM32 ONLY Design printed circuit boards. This is Eagle CAD's last 32-bit Linux release (7.7.0), emulated using Box86. Subsequent Eagle releases dropped 32-bit support. To run: Menu -> Programming -> Eagle To run in a terminal: eagle FreeCAD https://scruss.com/blog/2020/02/16/freecad-on-raspberry-pi-4/ - .deb compiled by @ryanfortner (GitHub) ARM32 ONLY 3D designer software. Unlike the repository's version of FreeCAD, this one actually works. Thanks to @ryanfortner, the FreeCAD app is now a deb, and installs in a few minutes instead of many hours! To run: Menu -> Graphics -> FreeCAD To run in a terminal: FreeCAD GIMP https://www.gimp.org/ - Made by The GIMP Team Added to Pi Apps by Lightstrike on Discord Package app Create images and edit photographs GIMP stands for \"GNU Image Manipulation Program\". Whether you are a graphic designer, photographer, illustrator, or scientist, GIMP provides you with sophisticated tools to get your job done. You can further enhance your productivity with GIMP thanks to many customization options and 3rd party plugins. To run: Menu -> Graphics -> GNU Image Manipulation Program To run in terminal: gimp Inkscape https://inkscape.org - 1Spinne in issue #1262 Package app Popular free vector graphics editor Whether you are an illustrator, designer, web designer or just someone who needs to create some vector imagery, Inkscape is for you! Flexible drawing tools Broad file format compatibility Powerful text tool Bezier and spiro curves Note: Also see the Boxy SVG tool. Intellij IDEA https://www.jetbrains.com/idea/ - Thanks to GlacierPark19 for suggesting this app be added. Botspot made it. ARM32/ARM64 IntelliJ IDEA is an IDE designed to maximize developer productivity. It does the routine and repetitive tasks for you by providing clever code completion, static code analysis, and refactorings, and lets you focus on the bright side of software development, making it not only productive but also an enjoyable experience. jGRASP IDE https://www.jgrasp.org/index.html - Botspot made this app. ARM32/ARM64 An IDE with visualizations for improving software comprehensibility. This IDE is used by many learning institutions and colleges for their classes. Kolourpaint https://apps.kde.org/kolourpaint/ - Botspot Package app An easy-to-use paint program. KolourPaint is a simple painting program to quickly create raster images. It is useful as a touch-up tool and simple image editing tasks. Features: - Support for drawing various shapes: lines, rectangles, rounded rectangles, ovals and polygons - Curves, lines and text - Colour picker - Selections - Rotation, monochrome, redaction and other advanced effects To run: Menu -> Graphics -> Kolourpaint To run in terminal: kolourpaint Lego Digital Designer https://github.com/Botspot/lego-digital-designer-rpi - Botspot ARM32 ONLY Play with virtual Lego blocks and create your own plans! This is Lego's official (discontinued) brick design program. With it, you can build your own sets within the editor and paint the pieces any color you wish. Afterwards, you can generate step-by-step building plans and print them out. Or you could place your creation into a desert background and take a picture of it to share with friends. This program runs extremely well on RPi. The only problem I (Botspot) could find was the sound effects don't work. LibreOffice https://www.libreoffice.org - Botspot Package app Free office suite including a word editor, slideshow, spreadsheet, database, and image editor To run: Menu -> Office -> LibreOffice To run in terminal: libreoffice To make it look and feel like Microsoft Office, see the \"Libreoffice MS Theme\" app! LibrePCB https://librepcb.discourse.group/t/how-to-install-librepcb-on-a-raspberry-pi/212 ARM32 ONLY Develop printed circuit boards. LinuxCNC http://linuxcnc.org - Thanks to the LinuxCNC community for creating LinuxCNC Thanks to Crilum on GitHub for making the scripts. ARM32 ONLY LinuxCNC controls CNC machines. It can drive milling machines, lathes, 3D printers, laser cutters, plasma cutters, robot arms, hexapods, and more. How to run: Menu -> Other -> LinuxCNC In Terminal: linuxcnc LinuxCNC is software that runs on Linux, on most standard PCs, that can interpret G-code and run a CNC machine. It was originally developed on a milling machine, but support was added for lathes and many other types of machine. It can be used with mills, lathes, plasma cutters, routers, robots, and so on. NixNote2 https://github.com/baumgarr/Nixnote2 - Botspot Package app Take notes, organize your schedule, and save websites with this offline and open-source Evernote client. To run: Menu -> Internet -> NixNote2 To run in a terminal: nixnote2 Notepad ++ https://notepad-plus-plus.org/ - App added to pi-apps by RPICoder ARM32 ONLY Notepad++ is a free source code editor and Notepad replacement that supports several languages. To Run: Menu -> Accessories -> Notepad++ This app runs with the help of box86 and wine. OpenSCAD http://www.openscad.org/ https://github.com/koendv/openscad-raspberrypi ARM32/ARM64 OpenSCAD is software for creating solid 3D CAD models. Unlike most free software for creating 3D models, OpenSCAD does not focus on the artistic aspects of 3D modelling but instead on the CAD aspects. OpenSCAD is more suitable for creating 3D models of machine parts but perhaps not when creating computer-animated movies. OpenSCAD is not an interactive modeller. Instead OpenSCAD is something like a 3D-compiler that reads in a script file that describes the object and renders the 3D model from this script file. This gives designers full control over the modelling process and enables them to easily change any step in the modelling process or make designs that are defined by configurable parameters. To run: Menu -> Graphics -> OpenSCAD To run in a terminal: OpenSCAD.AppImage Pinta https://www.pinta-project.com/ - Botspot Package app A powerful painting program including numberous adjustments, drawing tools, multiple layers, and a flexible interface. To run: Menu -> Graphics -> Pinta To run in a terminal: pinta Processing IDE https://processing.org/ - added by pi-dev500 ARM32/ARM64 Simple Java IDE Processing is an IDE + Programming Language used for Visual Arts. It is an Open-Source and Free Software (FOSS) which is built from Java and is used to create graphics. To run: Menu -> Programming -> Processing IDE To run in a terminal: ~/.local/share/processing-3.5.3/processing PrusaSlicer https://github.com/davidk/PrusaSlicer-ARM.AppImage ARM32/ARM64 Takes a 3D model and slices it for use in a 3D printer. Pycharm CE https://www.jetbrains.com/pycharm/ - Thanks to gam3t3chelectronicshobbyhouse a.k.a 'Gam3t3ch' for \"Installing PyCharm on Raspberry Pi 4\" from element14. Also, fabianmendes for introducing it into pi-apps. ARM32/ARM64 Python Community Edition IDE for Professional and Educational Developers. To run: Menu -> Programming -> Pycharm Community Edition To run in a terminal: /opt/pycharm-community/bin/pycharm.sh You must configure the IDE to run each script (\"py\" file), or create a new environment. For Educational purposes, the \"EDUtools\" plugin can be installed. Go to the right corner from the Pycharm start up portal: Configurate > Plugins > Search for: EDUtools > Install it and restart the IDE. Then you will able to select \"Learn and Teach\" for courses. Remarkable https://remarkableapp.github.io - Added to Pi-Apps by Itai-Nelken. Thanks to seiferteric on GitHub for providing the DEB package fix. ARM32/ARM64 A fully featured Markdown editor for Linux. Remarkable has many features including: - Live Preview with Synchronized Scrolling - Syntax Highlighting - GitHub Flavored Markdown Support - HTML and PDF Export - Dialogs for adding images, links and tables - Styles - Custom CSS Support - Keyboard Shortcuts Scratch 2 https://github.com/Botspot/scratch2 - Botspot ARM32 ONLY Scratch 2 was removed from RPiOS in January. Install it back with this app! Scratch 2 is significantly faster than Scratch 3. It uses far less CPU, and generally will run better than Scratch 3 on older Pies. To run: Menu -> Programming -> Scratch 2. To run in a terminal: scratch2 Scratch 3 https://scratch.mit.edu - Botspot Package app Enjoy learning computer programming with drag-n-drop blocks! This is Raspberry Pi's official electron build of Scratch 3 and it runs offline. To run: Menu -> Programming -> Scratch 3 To run in a terminal: /usr/lib/scratch3/scratch-desktop Note: Consider trying Turbowarp or Scratch 2 - both run faster than this version. Shotwell https://shotwell-project.org/doc/html/ - Botspot Package app Organize, edit, and publish your photos. To run: Menu -> Graphics -> Shotwell To run in terminal: shotwell StackEdit https://stackedit.io/ - Added to pi-apps by Itai-Nelken. webapps compiled by Itai-Nelken using nativefier. nativefier by jiahaog. ARM32/ARM64 Full-featured, open-source Markdown editor. StackEdit uses the same markdown library as Stack Overflow and is fully compatible with Github README.md files as well. This is Botspot's preferred tool to write the README for all his repositories. To run: Menu -> Programming -> StackEdit To run in a terminal: ~/stackedit/StackEdit Sublime Text https://www.sublimetext.com/ - Added to pi-apps by Itai Nelken ARM32/ARM64 Cross-platform source code editor with a Python application programming interface. It natively supports many programming languages and markup languages. Additional features can be added with plugins. To run: Menu -> Programming -> Sublime Text This runs Sublime Text v2 with the Box86 emulator. Turbowarp https://turbowarp.org/ - App added to pi-apps by Raspberry Pi News (bit.ly/rpnsite) Made by the TurboWarp dev team (https://github.com/TurboWarp/) ARM32/ARM64 Scratch 3 Desktop, but runs much faster. Also known as 'TurboWarp' TurboWarp is a Scratch mod that compiles projects to JavaScript to make them run really fast. Also has dark mode, addons, and more. It even works when you're offline, just like the original Scratch Desktop. To run: Menu -> Programming -> TurboWarp Visual Studio Code https://code.visualstudio.com/ - Install script written by RaspberryPiNews on YT Small change to description by CleanMachine1 Original program made by Microsoft ARM32/ARM64 Visual Studio Code is a free source-code editor made by Microsoft. Features include support for debugging, syntax highlighting, intelligent code completion, snippets, code refactoring, and embedded Git It supports most popular coding languages including Python, JavaScript, and more. Note: If you are using Raspberry Pi OS, you don't need to install this app. Just run \"sudo apt install code\" in the terminal. Pi-Apps will still continue to ship VSCode so that non-PiOS users can still have access to it. VSCodium https://vscodium.com/ - Added to pi-apps by @ryanfortner (Github) ARM32/ARM64 Visual Studio Code builds without the telemetry and tracking. Microsoft's vscode source code is open source (MIT-licensed), but the product available for download (Visual Studio Code) is licensed under this not-FLOSS license and contains telemetry/tracking. WPS Office https://www.wps.com - Botspot figured out how to instapp WPS Office on PiOS64. Botspot submitted this app to Pi-Apps. ARM64 ONLY This is the Chinese version of Microsoft Office. It is not open source, but works well on PiOS 64, and looks much more polished than Libreoffice or Openoffice. Games Amiberry https://github.com/midwan/amiberry/ - Program created by Dimitris Panokostas (midwan) on GitHub. Debian packages created by @ryanfortner (GitHub) Scripts created by @ryanfortner (GitHub) ARM32/ARM64 Amiberry is a well-optimized, high-performance emulator for running Amiga games on low-power ARM boards like Raspberry Pi. Run it via the main Menu > Games > Amiberry. AstroMenace https://github.com/viewizard/astromenace - All contributer in github page added to pi-apps by Painadath samuelpainadath@gmail.com ARM32/ARM64 Immerse into a decisive battle against tons of cunning foes, face the terrifying bosses and protect your homeland throughout 15 diverse levels of the game. The hardcore gameplay of AstroMenace, packed with pure non-stop action, will become a full scale test for your basic instinct of survival. Chiaki https://github.com/Fredrum/chiaki/wiki/Chiaki-for-the-Raspberry-Pi - Chiaki software implementation by Florian M\u00e4rkl: https://github.com/thestr4ng3r Raspberry Pi fork implementation by Blueroom VR: https://github.com/Fredrum Added to Pi-Apps by Markieautarkie: https://github.com/Markieautarkie ARM32/ARM64 Chiaki is a free and open source software client which enables PlayStation 4/5 remote play on the Raspberry Pi. Chiaki wiki: https://git.sr.ht/~thestr4ng3r/chiaki Pi fork wiki: https://github.com/Fredrum/chiaki/wiki/Chiaki-for-the-Raspberry-Pi To run: Menu -> Games -> Chiaki To run in a terminal: Chiaki/build/gui/chiaki ----- Usage ----- Once Chiaki is running, you can enter the settings menu (top right) to configure general/stream settings to your liking. Note that stream quality options are limited depending on your console. To connect and use a controller with Chiaki, please refer to the Pi fork wiki. In most cases, Chiaki will automatically detect your console if it's turned on. Otherwise, you can add it manually by pressing the \"+\" icon (top right) and entering your console's IP address. To finalize the registration, two more parameters need to be set. PSN AccountID: In a terminal, enter \"python3 Chiaki/psn-account-id.py\" and follow the instructions. Registration PIN: On a PS4, go to: Settings -> Remote Play -> Add Device; On a PS5, go to: Settings -> System -> Remote Play -> Link Device. You can now double-click your console in Chiaki's main window to start remote play! Descent 1 https://www.dxx-rebirth.com/ ARM32 ONLY D1X-Rebirth - source port of Descent: First Strike from 1995 This package installs the shareware version, if you own the full game you can copy the game data to ~/.d1x-rebirth directory (replacing existing files). To run: Menu -> Games -> Descent 1 To run in a terminal: ~/.d1x-rebirth/d1x-rebirth-rpi -hogdir ~/.d1x-rebirth To exit: select \"Quit\" in the game's main menu. Descent 2 https://www.dxx-rebirth.com/ ARM32 ONLY D2X-Rebirth - source port of Descent 2: Counterstrike from 1996 This package installs the shareware version, if you own the full game you can copy the game data to ~/.d2x-rebirth directory (replacing existing files). To run: Menu -> Games -> Descent 2 To run in a terminal: ~/.d1x-rebirth/d1x-rebirth-rpi -hogdir ~/.d1x-rebirth To exit: select \"Quit\" in the game's main menu. Doom 3 https://github.com/techcoder20/RPIDoom3Installer.git - Script Created By RPI Coder Added To Pi apps by Botspot Testers: Lukefrenner Botspot Nikolay Dubnov ARM32 ONLY Doom 3 is a 2004 horror first-person shooter video game developed by id Software and published by Activision. In this game a massive demonic invasion has overwhelmed the Union Aerospace Corporation's (UAC) Mars Research Facility, leaving only chaos and horror in its wake. As one of only a few survivors, you must fight your way to hell and back against a horde of evil monsters. Godot https://github.com/hiulit/Unofficial-Godot-Engine-Raspberry-Pi - Credits to Irtexo for putting it on Pi-Apps. Credits to Hiulit for porting it to the Rpi. Credits to Juan Linietsky and Ariel Manzur for creating Godot. ARM32/ARM64 Open Source Game Engine that's run fine on Rpi (for 2d games). For the export instructions for Rpi go to the website. This Software only run on Rpi4 GLES2 Projects are recommended. To run: Menu -> Programming -> Godot To run in a terminal: ~/Godot/godot_3.4-stable_rpi4_editor_lto.bin Heroes 2 https://github.com/ihhub/fheroes2 ARM32 ONLY Free implementation of Heroes of Might and Magic II game engine. This package installs the shareware version, if you own the full game you can copy the game data to ~/.fheroes2 directory (replacing existing files). To run: Menu -> Games -> Free Heroes 2 To run in a terminal: ~/.fheroes2/fheroes2-rpi Minecraft Bedrock https://github.com/ChristopherHX/linux-packaging-scripts/releases/tag/appimage - Install script written by RaspberryPiNews on YT Appimage made by ChristopherHX on Github Program made by everyone at minecraft-linux on Github ARM32/ARM64 Unoffical launcher for Minecraft Bedrock edition NOTE: For better performance and smooth FPS, we recommend an older Bedrock version like 1.16.40 as it doesn't contain renderdragon or RTX code. Run with the menu app \"Minecraft Bedrock Launcher\" or with the command \"GALLIUM_HUD=simple,fps /opt/MCBedrock.AppImage\" \u2219 Sign in with a Google Play account with Minecraft purchased \u2219 Active comunity to ask for help \u2219 FPS Counter mod \u2219 And much more! Minecraft Java https://www.lunarclient.com/ - Lunar Client is developed by MoonsworthLLC The ARM fork of Lunar Client is maintained by gl91306 on Github: https://github.com/gl91306/lunar ARM lwjgl libs uploaded by rpiMike on the Raspberry Pi Forums Install script written by RaspberryPiNews on Youtube/mobilegmYT on Github Scripts re-written by Botspot ARM32/ARM64 Minecraft Java - now supports Microsoft accounts and Optifine! This installs a fork of Lunar Client, with built in Optifine and other mods for maximum out-of-the-box performance. To run: Menu -> Games -> Minecraft Launcher To run in a terminal: ~/lunarassets/lunarclient.AppImage NOTE: For best performance (60 FPS+), we recommend an older version of Minecraft like 1.12.2 or 1.8 Why lunar? - It's easy to use and to setup. - It is well-maintained and has a vibrant support community. - It supports Microsoft and Mojang accounts. - This fork of Lunar for ARM includes Optifine, automatically switches lwjgl libraries (for playing older versions), and includes other optimizations by default. - It's easy to install in a self contained AppImage. Need help? Please open an issue on this repository: https://github.com/gl91306/lunar Minecraft Java MultiMC5 https://github.com/cobalt2727/L4T-Megascript/blob/master/scripts/games_and_emulators/minecraft_java_multimc.sh - Install script written by theofficialgman based on the version for the L4T Megascript ARM32/ARM64 NOTE: For best performance, we recommend a version like 1.12.2 + Optifine or the latest Minecraft with Optifabric or Sodium/Lithium/Phosphor Fabric Mods. Minecraft Java MultiMC5 for the Raspberry Pi To run: Menu -> Games -> MultiMC To run in a terminal: ~/MultiMC/install/MultiMC Link to the Raspberry Pi Forum Post: https://forums.raspberrypi.com/viewtopic.php?f=78&t=321888 The MultiMC5 Wiki can be found here: https://github.com/MultiMC/MultiMC5/wiki If you need help installing Optifine: https://github.com/MultiMC/MultiMC5/wiki/MultiMC-and-OptiFine the MultiMC5 install script contains OS detection (ubuntu and debian/raspbian based systems supported), and automatic java 8, 11, and 16 download and installation MultiMC5 supports mojang, microsoft account login, and microsoft gamepass support, and minecraft versions from the old beta/alphas all the way up to 1.17+. Fabric and Forge mod loading is supported for the applicable minecraft versions A custom meta repo is used for arm32 and arm64 to provide lwjgl 2.9.4, 3.1.2(fake), 3.1.6, 3.2.1, 3.2.2, and 3.2.3(unused) native libraries. (https://github.com/theofficialgman/meta-multimc) This supports all currently released versions of minecraft. Note: MultiMC5 does not give support for custom builds If you have found a bug and it is re-producible on official MultiMC5 builds, then it can be submitted at https://github.com/MultiMC/MultiMC5/issues. Otherwise, bugs should be submitted to https://github.com/Botspot/pi-apps/issues Minecraft Pi (Modded) https://discord.com/invite/aDqejQGMMy - Game mods and jMCPIL made by TheBrokenRail#5376 on Discord gMCPIL made by Alvarito050506#8207 on Discord Ported to Pi-Apps by TheBrokenRail#5376 on Discord with a little help from Botspot. ARM32/ARM64 A modded version of Minecraft: Pi Edition with things like survival mode, multiplayer support, and more! To open the launcher: Menu > Games > gMCPIL or jMCPIL, depending on which version you chose at install time. Use the launcher to set up mods and multiplayer. Need help? Consider asking on MCPI Modded's Discord server instead: https://discord.gg/3wXu3xtr Controls: WASD to move Mouse to look around F1 key to hide HUD F5 to switch to 3rd person view Notes: You must be in gamemode survival and have Touch GUI enabled to use Chests, Crafting Tables, etc. To make a crafting table, press \"E\" and then go to the Craft menu in the upper left-hand corner. Click on what you want to craft, then click the big button with all of the stuff needed to craft the item to craft it. Mouse scroll doesn't exist, you need to use your mouse to drag stuff like the crafting menu. PPSSPP (PSP emulator) http://ppsspp.org - Added to pi-apps by @ryanfortner (Github) ARM32/ARM64 A PSP emulator that can run PSP games in full HD and can upscale textures also. How to run: Menu > Games > PPSSPP Steam https://www.tomshardware.com/how-to/raspberry-pi-install-steam ARM32 ONLY This emulates the x86_32bit Linux version of Steam using Box86. To run: Menu -> Games -> Steam Steam Link Botspot Package app The Steam Link app brings desktop gaming to your Raspberry Pi. Just pair a controller to your device, connect to a computer running Steam on the same local network, and start playing your existing Steam games. To run: Menu -> Games -> Steam Link To run in a terminal: steamlink Stunt Rally http://stuntrally.tuxfamily.org/ - Compiled and packaged into a deb by Itai-Nelken. Added to pi-apps by Itai-Nelken. ARM32/ARM64 Racing game with rally style driving, mostly on gravel. WARNING: at least 2GB of free disk space is needed! Pi-Apps automatically sets the game's settings for best performance. Feel free to experiment and find the best settings for you. Stunt Rally features a rich variety of 172 tracks in 34 sceneries also on other planets. Track difficulty ranges from short and easy, to very difficult stunt tracks including jumps, skewed loops, pipes winding in 3D, obstacles, or all of the above. Vehicle options: 20 cars, 1 motorbike, 3 hovering spaceships and 1 bouncing sphere. The latter provide a fast and easier gameplay on flat tracks. Game modes include: Single Race, Tutorials, Championships, Challenges, Multiplayer and Split Screen. Also Replays and Ghost drive are present. The Track Editor allows creating and modifying tracks. It uses a 3D spline generated road. To run: Menu -> Games -> Stunt Rally To run in terminal: stuntrally To run track editor: Menu -> Games -> Stunt Rally Track Editor To run in terminal: sr-editor Unciv https://github.com/yairm210/Unciv - Added by Md. Touhidur Rahman Github: https://github.com/touhidurrr Website: https://touhidur.xyz Temurin Installation Script by theofficialgman Github: https://github.com/theofficialgman Enhanced Descriptions and Script Reviews by cycool29 Github: https://github.com/cycool29 Tested by Botspot Github: https://github.com/Botspot ARM32/ARM64 An open-source, mod-friendly Android+Desktop remake of Civ V A reimplementation of the most famous civilization-building game ever\u2014fast, small, no ads, free forever! Build your civilization, research technologies, expand your cities and defeat your foes! To run: Menu -> Games -> Unciv Internet Angry IP scanner https://angryip.org - Added to pi-apps by Itai-Nelken. Big thanks to chunky-milk for finding that this app works on the rpi. https://github.com/chunky-milk/pi-bashscripts-files/tree/main/angry-ip-scanner ARM32/ARM64 Scans local networks as well as Internet IP Range, Random or file in any format. Exports results into many formats, Extensible with many data fetchers, Provides command-line interface, Free and open-source. AnyDesk https://anydesk.com/en/downloads/raspberry-pi - @fabianmendes just brought it to the pi-apps. ARM32 ONLY AnyDesk is the ultimate remote desktop solution for editing and maintaining a desktop or server from a remote location using Linux on Raspberry Pi. Enjoy smooth and seamless remote operation of external computer systems. AnyDesk is free for private use and offers flexible license models for organizations. HOW TO RUN: JUST CLICK AND RUN. Caprine https://sindresorhus.com/caprine/ ARM32/ARM64 Caprine is an unofficial and privacy focused Facebook Messenger app with many useful features. Built with Electron, Caprine features a Dark mode, keyboard shortcuts, ability to toggle last seen/typing indicators, work chat support, code blocks, custom text size, and an interface that adapts to resizing windows. Caprine is a third-party app and is not affiliated with Facebook. CloudBuddy https://github.com/Botspot/cloudbuddy - Botspot made, Botspot added. ARM32/ARM64 CloudBuddy is the ultimate wizard for cloud storage. Google Drive, Onedrive, Dropbox, and many more. Botspot made this gui frontend for the popular rclone tool to connect to your cloud drives, download from them, upload to them, mount them to your file manager, and more. In addition, CloudBuddy features an interactive file browser to easily generate shareable links and to perform various server-side operations. To run: Menu -> Internet -> CloudBuddy To run in terminal: ~/cloudbuddy/main.sh Deluge https://www.deluge-torrent.org - Botspot Package app Lightweight BitTorrent client Use this to download torrent files from the Internet. For example, you can download a Torrent version of Raspberry Pi OS. To run: Menu -> Internet -> Deluge To run in a terminal: deluge-gtk Also see the Transmission app. Note: Torrents can contain illegal material, like pirated movies or cracked games. You use Deluge at your own risk. Deskreen https://deskreen.com/ - Thanks to pavlobu and all contibuters for developing Deskreen. Thanks to Crilum on GitHub for making the scripts. Thanks to ryanfortner on GitHub for having and hosting the debs! ARM32/ARM64 Share your desktop to your browser, and turn any device into a second screen! How to run: Menu -> Programming -> Deskreen or run from your Terminal: deskreen Discord https://github.com/SpacingBat3/WebCord/ - Discord app by SpacingBat3 ARM32/ARM64 Fast Discord client for ARM that mimics the official Discord client. To run: Menu -> Internet -> WebCord. To run in a terminal: webcord The app runs independent to chromium and can be hidden to the system tray unlike other solutions out there. Made by SpacingBat3 on Github with care :) Email Checker https://github.com/Botspot/raspi-email-checker ARM32/ARM64 Continuously checks for new emails and display a notification if there are any. When you click install, a window will appear for you to enter the email account's information and the time interval to check. If you want to change the settings later, just click the Install button again. Originally adapted from: https://learn.adafruit.com/raspberry-pi-e-mail-notifier-using-leds/python-script Filezilla https://filezilla-project.org/ - Botspot Package app Download and upload files via FTP, FTPS, and HTTP This all allows you to connect to file-sharing servers on your home network or on the world wide web. To run: Menu -> Internet -> Filezilla To run in terminal: filezilla Note: For more cloud-storage, see the CloudBuddy app. Lokinet https://wiki.oxen.io/wiki/Main_Page - This application is a product of ongoing research and various tool development of the Oxen Privacy Tech Foundation. https://optf.ngo/ ARM32/ARM64 Lokinet is a privacy focused network anyone can access using the latest in decentralized onion routing technology. Lokinet requires no internet IP Address but instead provides it's own network addresses which can be either ephemeral, persistent or personalized depending on the users desired application. Information is onion routed through a globally distributed network of over one thousand nodes. Hosting on Lokinet is quite easy and allows users to instantly create static addresses that can be privately accessed remotely over the internet for hosting their own online content. Using a Lokinet \"SNApp\" alleviates many of the challenges associated with hosting when it comes to configuring ports on a network. WIth SNApps there are no ports to forward. SNApps can be easily hosted on as little as an SBC inside a network and privately accessible anywhere in the world. SNApps also can hosted on a VPN using webservers such as Nginx, Apache, python etc. thereby allowing private anonymized global access your own personal content or sharing content privately among other users of the network. Web based applications such as IRC, Mumble, PeerTube, Pleroma, forums, streaming content etc. are all supportable through the network. The location and origin of the server is hidden and users anonymized while additionally the server can be secured in traditional ways. One can also register custom domains if they so choose to but this is not required to immediately generate a static address. Users wishing to access the regular internet anonymously need not pay for access to use Lokinet but may chose to subscribe to an exit provider should they wish to enhance anonymous access the internet through such a provider. Additionally the network generally has free exit nodes available offered through individuals providing voluntary support to the network. Currently the Oxen Privacy Tech Foundation offers free Lokinet exit node access at address \"exit.loki\". A wiki for Lokinet is located at https://wiki.oxen.io/wiki/Main_Page Microsoft Teams https://github.com/IsmaelMartinez/teams-for-linux - @IsmaelMartinez on GitHub for the creation of the app. ARM32/ARM64 Microsoft Teams is a proprietary business communication platform developed by Microsoft, as part of the Microsoft 365 family of products. Teams primarily competes with the similar service Slack, offering workspace chat and videoconferencing, file storage, and application integration. To run: Menu -> Internet -> Teams Build with nativefier. Persepolis Download Manager https://persepolisdm.github.io/ ARM32/ARM64 Persepolis is a Download Manager and a GUI For aria2. It's written in Python. Persepolis is a Sample of Free and open source software. It's developed For GNU/Linux Distributions, BSDs, macOS and Microsoft Windows. SpeedTest-CLI https://www.speedtest.net/ ARM32/ARM64 Test your internet speed from a terminal! Are you familiar with speedtest.net? This tool is created by the same team. This version is much newer than the speedtest-cli package available in the repositories. To run: Menu -> Internet -> Run Speedtest To run in a terminal: speedtest TeamViewer Host https://github.com/Benmac83/Teamviewer-installer-for-pi - Credits go to @Benmac83 on the Botspot discord server ARM32 ONLY Remote desktop server software. To run: Menu -> Internet -> TeamViewer Host To run in terminal: teamviewer If you get an error running it from command line follow the instructions it gives you. They're very simple to follow. Telegram https://github.com/telegramdesktop/tdesktop ARM32/ARM64 Telegram is a free and open source, cross-platform, cloud-based instant messaging software. This service also provides end-to-end encrypted video calling, VoIP, file sharing and several other features. To run: Menu -> Internet -> Telegram Desktop To run from terminal: telegram-desktop Thunderbird https://www.thunderbird.net/features - Botspot Package app Email client with many features like a tabbed interface, smart spam filter, address book, search and filter tools, encryption, and numerous add-ons. To run: Menu -> Internet -> Thunderbird To run in a terminal: thunderbird Transmission https://transmissionbt.com - Botspot Package app Lightweight BitTorrent client Use this to download torrent files from the Internet. For example, you can download a Torrent version of Raspberry Pi OS. To run: Menu -> Internet -> Transmission Also see the Deluge app. Note: Torrents can contain illegal material, like pirated movies or cracked games. You use Transmission at your own risk. Web Apps https://itsfoss.com/web-app-manager-linux-mint/ - Phoenixbyrd for making it install successfully Botspot made the app. ARM32 ONLY Run websites as if they were apps. This is Linux Mint's official Web Apps program. Using it, you can run any website as a standalone app. If there are multiple browsers installed on the system, Web Apps will let you choose which one to use. It also lets you select an icon, menu category, and text label. When finished, a new button will appear in the main menu. To run: Menu -> Internet -> Web Apps To run in a terminal: webapp-manager Wechat https://www.wechat.com/en/ - Install script written by RaspberryPiNews on YT With help from chills340 on Discord Script edits made by Botspot. Botspot was unable to login and test everything though. ARM32 ONLY WeChat is a Chinese multi-purpose instant messaging, social media and mobile payment app developed by Tencent. It was first released in 2011, it became the world's largest standalone mobile app in 2018, with over 1 billion monthly active users. WeChat provides text messaging, hold-to-talk voice messaging, broadcast (one-to-many) messaging, video conferencing, video games, sharing of photographs and videos and location sharing. WeChat Desktop App: - Run with box86 and wine - Smooth performance - Everything from gifs to emojis to images all work To run: Menu -> Internet -> WeChat WhatsApp no website - Apps compiled using Nativefier and scripts written by Itai-Nelken Nativefier made by jiahaog. Thanks to Botspot for help with debugging the menu shortcut and for creating pi-apps! ARM32/ARM64 Nativefier Whatsapp Web webapp A simple Whatsapp Web chromium webapp wrapped in electron with nativefier. it has a tray icon, so it doesn't take space on the taskbar, but keeps running in the background. To run: menu>internet>Whatsapp Web Xtreme Download Manager https://xtremedownloadmanager.com ARM32/ARM64 Xtreme Download Manager is a powerful tool to increase download speed up-to 500%, save and convert streaming videos from thousands of websites, resume broken/dead downloads and schedule downloads. XDM seamlessly integrates with Google Chrome, Mozilla Firefox Quantum, Opera, Vivaldi and many popular browsers, to take over downloads and saving streaming videos from web. XDM has built in video converter which lets you convert downloaded videos to popular MP4 and MP3 formats. Support for HTTP, HTTPS, FTP, DASH, HLS, HDS protocols, firewalls, proxy servers, PAC scripts, file redirects, cookies, authorization, download queue, scheduler and many more feature makes XDM a very useful tool Zoom https://github.com/Botspot/pi-apps/issues/188 ARM32/ARM64 Zoom video calls on the Raspberry Pi. This is the full desktop app, so you can do virtual backgrounds and Gallery View! This works by running the 32-bit x86 Zoom Linux app inside the box86 emulator. Performance is good enough on the Pi4. Turning off HD video in Zoom's settings is recommended. Zoom PWA https://github.com/Botspot/zoom-pwa - Botspot ARM32/ARM64 Web-app for Zoom This is basically a web browser running Zoom's new Progressive Web App. Performance is better in some ways and worse in others. This app should be considered a backup option, only used if the regular Zoom app doesn't work at all. Both versions can be installed at the same time and will not interfere with each another. Note: this app requires you to have chromium-browser, chromium, or google-chrome installed. Let us know if your Chromium-based browser is not detected by the script. To run: Menu -> Internet -> Zoom PWA To run in a terminal: cat ~/.local/share/applications/chrome-gbmplfifepjenigdepeahbecfkcalfhg-Zoom-PWA.desktop | grep Exec | sed 's/Exec=//g' | bash Internet/Browsers Browsh https://www.brow.sh/ ARM32/ARM64 The modern text-based terminal browser. Browsh is a modern text-based browser for the terminal. It renders anything that a modern browser can; HTML5, CSS3, JS, video and even WebGL. Its main purpose is to be run on a remote server and accessed via SSH/Mosh or the in-browser HTML service in order to significantly reduce bandwidth and thus both increase browsing speeds and decrease bandwidth costs. To run: Menu -> Internet -> Browsh To run in a terminal: browsh NOTE: This will also install firefox-esr Chromium Botspot Package app Open-source version of Google Chrome. If you are using Raspberry Pi OS, this browser has been optimized by the Raspberry Pi Foundation to include hardware acceleration and other various performance improvements. To play Netflix, Spotify, or other protected multimedia streams, see the Chromium Widevine app. To install an older version of Chromium, see the Downgrade Chromium app. Chromium supports numerous flags to enable extra features. You can add these flags either manually (by running chromium-browser in a terminal), or by adding the flag to a file in the /etc/chromium/customizations folder. Here's how that works: Inside the /etc/chromium/customizations folder there will be one or more files. On most systems there will already be a 00-rpi-vars file there. You can add flags to it, or create a new file. In all cases, be sure it starts with: CHROMIUM_FLAGS=\"${CHROMIUM_FLAGS} And be sure it ends with this character: \" Now that you know how to add flags to Chromium, here are some useful ones: - Enable Google Chrome Sync: --oauth2-client-id=77185425430.apps.googleusercontent.com --oauth2-client-secret=OTJgUOQcT7lO7GsGZq2G4IlT This flag is discussed in the Raspberry Pi Forums: https://forums.raspberrypi.com/viewtopic.php?t=314477 - Enable dark mode: --force-dark-mode If you want more themes, go visit the Chrome Web Store: https://chrome.google.com/webstore/category/themes - Change the scale of the browser window: --force-device-scale-factor=1.3 The default is 1 - smaller values will shrink the interface, while larger values will grow the interface. - More chromium flags can be found on this website: https://peter.sh/experiments/chromium-command-line-switches Downgrade Chromium https://www.raspberrypi.org/forums/viewtopic.php?f=63&t=308303 ARM32 ONLY Change Chromium versions easily. Chromium 65, 72, 74, 78, 84, 86, 88, 92, and 95. Uninstall the app to go back to the latest Chromium version available. Beware that downgrading Chromium versions can mess up your config folder. To be safe, this app makes a backup of Chromium's config folder. When uninstalling, you will have the opportunity to restore the backup config folder. All deb files are downloaded from https://archive.raspberrypi.org/debian/pool/main/c/chromium-browser Falkon https://falkon.org ARM32/ARM64 Falkon is a KDE web browser using QtWebEngine rendering engine, previously known as QupZilla. It aims to be a lightweight web browser available through all major platforms. This project has been originally started only for educational purposes. But from its start, Falkon has grown into a feature-rich browser. Falkon has all standard functions you expect from a web browser. It includes bookmarks, history (both also in sidebar) and tabs. Above that, it has by default enabled blocking ads with a built-in AdBlock plugin. To run: Menu -> Internet -> Falkon Firefox Rapid Release Scripts made by chunky-milk Added to Pi-Apps by Tejas Singh YT Original Web-Browser made by Mozilla Foundation. ARM32/ARM64 Latest stable Mozilla Firefox version available. (Downloaded from Ubuntu Repo) Mozilla Firefox, is a free and open-source web browser developed by the Mozilla Foundation. To run: Menu -> Internet -> Firefox Web Browser To run in terminal: firefox Min https://minbrowser.org/ - @ryanfortner (GitHub) ARM32/ARM64 A fast, minimal browser that protects your privacy. To run: Menu -> Internet -> Min To run in terminal: min Pale Moon https://www.palemoon.org/ - Botspot ARM32/ARM64 A distant fork of Firefox, this is a lightweight and customizable web browser. Pale Moon offers you a browsing experience in a browser completely built from its own, independently developed source that has been forked off from Mozilla's code a number of years ago, with carefully selected features and optimizations to improve the browser's stability and user experience, while offering full customization and a growing collection of extensions and themes to make the browser truly your own. To run: Menu -> Internet -> Pale Moon To run in terminal: palemoon Puffin https://www.puffin.com/raspberry-pi/ - Botspot added this app to Pi-Apps. ARM32 ONLY Speeds up web browsing thanks to cloud servers. This web browser uses cloud servers to load websites for you, instead of making your Pi do it all. Result: a claimed 1600% browsing speed increase. To run: Menu -> Internet -> Puffin Internet Terminal (Demo) To run in a terminal: puffin-internet-terminal-demo Quartz https://github.com/ksharindam/quartz-browser-qt5 ARM32/ARM64 A useful fast Web Browser for Windows and Linux written in pyqt5 webkit. This browser is aimed at ease of use, faster page loading, very short startup time. This has minimal settings to avoid confusion.Yet it has most useful settings, such as load images on/off, javascript on/off, change font. To save pages to read later, print feature can be used to save as pdf. And it can also export the whole page as png image. Tor https://sourceforge.net/projects/tor-browser-ports/files/ ARM32/ARM64 The Tor Browser is a web broswer that anonymizes your web traffic using the Tor network, making it easy to protect your identity online. Vivaldi https://vivaldi.com - Big thanks to chunky-milk for app idea and install script: https://github.com/chunky-milk/pi-bashscripts-files/tree/main/vivaldi Icon, description, and everything else required by pi-apps by Itai-Nelken ARM32/ARM64 Fast, private browser with unique features. Official Vivaldi browser for ARM Linux. Multimedia Audacious https://audacious-media-player.org/ - Botspot Package app Lightweight but flexible audio player This is a playlist-style audio player, allowing you to drag folders and files to the list. It includes numerous audio effects, visualizations, and skins - even several Winamp ones! To run: Menu -> Sound & Video -> Audacious To run in a terminal: audacious Audacity https://www.audacityteam.org/ - Botspot Package app Easy-to-use audio editor with numerous features Supports live-recording, import/export, editing, effects, plugins, visualizations, keyboard shurtcuts, and much more. To run: Menu -> Sound & Video -> Audacity To run in a terminal: audacity Also see MuseScore2 and Sonic-Pi Bongo Cam https://github.com/kuroni/bongocat-osu - Install code made by Raspberry Pi News on Youtube Original app made by kuromi: https://github.com/kuroni/bongocat-osu ARM32 ONLY If you want to make a video but don't want to show your face, why not use this animated cat program? This app displays a cat. It can type on the keyboard or move the mouse. It mirrors your mouse movements. Default keyboard shortcuts: Z and X to tap on the keyboard, C to wear sunglasses, and V to wave. Go here for configuration options: https://github.com/kuroni/bongocat-osu/wiki/Settings NOTE: The app files are stored in ~/bongocam/ Chromium Widevine https://github.com/Botspot/chromium-v84-widevine ARM32 ONLY Widevine DRM support for any version of chromium-browser. This adds ChromeOS's Widevine video decoding library to Chromium, and creates a second menu button with a ChromeOS user-agent. All websites will think your Pi is a Chromebook! Unlike Ventz's Chromium Media Edition, or even the official libwidevinecdm0 package, this app is unique to support all versions of Chromium, before version 84 and after version 84. Feel free to downgrade your browser for better video performance! (Using the \"Downgrade Chromium\" app) To run: Menu -> Internet -> Chromium Widevine. To test DRM: https://bitmovin.com/demos/drm For normal browsing, it's advisable to use the standard Chromium launcher. This is known to work on these websites: \u2022 Netflix \u2022 Hulu \u2022 Amazon Prime \u2022 Disney+ \u2022 HBO \u2022 Spotify \u2022 Pandora \u2022 Hoopla \u2022 MUBI \u2022 BritBox \u2022 Bell Satellite TV FreeTube https://freetubeapp.io/ - Installation Script and added to Pi-Apps by RPICoder ARM32/ARM64 Privacy-friendly YouTube player. Use YouTube without advertisements and prevent Google from tracking you with their cookies and JavaScript. FreeTube has an interface similar to YouTube, but is slower and more innefficient than YouTubuddy. Try both and see which one you prefer! Disabling the compositor improves playback performance. Kodi https://kodi.tv/about - Botspot Package app Kodi is the ultimate entertainment center. Kodi excels at: - Movies - TV Shows - Music - Photos - Games - Skins and add-ons - Controllable with mouse, keyboard, web interface, smartphone apps, game controllers, and TV remotes To run: Menu -> Sound & Video -> Kodi To run in a terminal: kodi To make this run on startup, consider using the Autostar app. MuseScore https://musescore.org - Botspot Package app Professional music notation software To run: Menu -> Sound & Video -> MuseScore 2 To run in terminal: mscore OBS Studio https://obsproject.com/ - Install script made by Botspot and RPICoder :) ARM32/ARM64 Free and open source software for video recording and live streaming. To run: Menu -> Sound & Video -> OBS Studio To run in a terminal: obs SimpleScreenRecorder https://www.maartenbaert.be/simplescreenrecorder/ - App Made by: MaartenBaert Suggestion from Kolpix Package app Feature-rich screen recorder for X11 and OpenGL Simple Screen Recorder is, despite its name, an actually feature-rich screen recorder. The name reflects the fact that it is simple to use unlike many other free screen recording applications available. It can be easily configured to start recording from an intuitive wizard-like interface. It can record the entire screen or part of it directly. The recording can be paused and resumed at any time. Many different file formats and codecs are supported. To perform an X11 recording, all it takes is selecting an area on the root window with the mouse, choosing an output file and pressing record, either by using the mouse or using a hotkey. It has a Qt-based graphical user interface. Its complexity becomes apparent in its powerful features. It allows one to record X11 screen areas and fullscreen OpenGL applications including sound supporting both ALSA, PulseAudio, JACK and OSS. It uses libavformat to encode the recorded material into a variety of video formats. Scaling the recorded video is possible as well as configuring the encoding quality for the codec chosen directly from the user interface. Sonic Pi https://sonic-pi.net/#rp ARM32 ONLY Write code to make music. Latest version of Sonic Pi. WACUP (new WinAmp) https://getwacup.com/ - Botspot for the scripts ralf1307 (github) issue #192 for the suggestion. ARM32 ONLY Cross-platform audio player - emulated Windows app YouTubuddy https://github.com/Botspot/youtubuddy - Botspot added this to Pi-Apps. ARM32/ARM64 Simple YouTube search engine, downloader and player. - No web browser required! Easily search for videos and play them with a few clicks. - Extremely lightweight - one bash script. - Perfect for downloading/playing batches of videos with a few clicks. - Supports searches, playlist URLs, and direct YouTube links. In addition, this supports URLs to many other video sites for easy downloading. Tools Alacritty Terminal https://github.com/alacritty/alacritty - Thanks to all contributors of the Alacritty project! Thanks to jmcerrejon on GitHub for making the compiling scripts! Thanks to ryanfortner on GitHub for hosting the deb, and cycool29 for making debs! Thanks to Crilum on GitHib for making the scripts! ARM32/ARM64 A fast, cross-platform, OpenGL terminal emulator Run from Menu: Menu -> System Tools -> Alacritty Run from Terminal: alacritty or with full path: /opt/alacritty/alacritty All Is Well https://github.com/spectrumgamer75/All-is-well ARM32/ARM64 ALL IS WELL is a bash script that allows users to easily update and upgrade their repositories and packages on linux. It will also fix any broken packages and dependencies. Forget about typing all update/upgrade commands manually, when ALL IS WELL! AndroidBuddy https://gitlab.com/gazlene/droidbuddy - Made by gazlene#8088 on Discord Added to pi-apps by Raspberry Pi News and Botspot ARM32/ARM64 A GUI for Android device recovery and maintenance. To run: Menu > Accessories > AndroidBuddy To run in a temrinal: python3 ~/droidbuddy/main.py Features: - APK Installation: Install an Android application package with ease. - Screen viewing and interaction: Control your device through an scrcpy window. - Recover files: Allows you to back up music, downloads, photos or all of your device's files. - AND MORE! Check out the website for more info. AntiMicroX https://antimicrox.github.io/ - Thanks to: - All contributers for creating AntiMicroX. - ryanfortner for his information on how to build AntiMicroX. - Crilum on GitHub for writing the install/uninstall scripts. ARM32/ARM64 A graphical program used to map keyboard buttons and mouse controls to a gamepad. Useful for playing games with no gamepad support. Run from Menu: Menu -> Accesories -> AntiMicroX Run from Terminal: antimicrox Autostar https://github.com/Botspot/autostar - Botspot made, Botspot added. ARM32/ARM64 Simple utility to make programs run on boot. The sky's the limit. People use this to: - Launch a website automatically, on boot. - Start a backup. - Launch your favorite apps on boot so they are ready to use sooner. - See what other apps have added autostart entries, and customize/disable them. To run: Menu -> Accessories -> AutoStar To run in terminal: ~/autostar/main.sh BalenaEtcher https://www.raspberrypi.org/forums/viewtopic.php?f=62&t=255205&start=25#p1564958 - Etcher .deb compiled by Itai Nelken. ARM32/ARM64 Flash SD cards with a disk image. Many file types supported. To run: Menu -> Accessories -> BalenaEtcher To run in a terminal: /opt/balenaEtcher/balena-etcher-electron BleachBit https://www.bleachbit.org/ ARM32/ARM64 BleachBit is a free and open-source disk space cleaner, privacy manager, and computer system optimizer. Not outdated like the APT repo's BleachBit. Like CCleaner on Windows, BleachBit frees space by deleting unimportant files and helps maintain your privacy by deleting sensitive data. And, just like CCleaner, there\u2019s more you can do with BleachBit than just clicking a single button. Better than free, BleachBit is open source. Comparison to APT version: - Nicer GUI look - With Abort function - With many function not included in APT version (Shred path from clipboard,make chaff and etc) - Clean deeper - Official dark theme support - Support showing debug messages Box64 https://github.com/ptitSeb/box64 - ptitseb for creating box64 debs made by @ryanfortner (GitHub) ARM64 ONLY Easily emulate x86_64 linux apps on Raspberry Pi. Box64 lets you run x86_64 Linux programs (such as games) on non-x86_64 Linux systems, like ARM (host system needs to be 64bit little-endian). Because Box64 uses the native versions of some \"system\" libraries, like libc, libm, SDL, and OpenGL, it's easy to integrate and use with most applications, and performance can be surprisingly high in many cases. Box86 https://github.com/ptitSeb/box86 - Itai-Nelken for his box86 debs and script creation ARM32 ONLY Easily emulate x86 linux apps on Raspberry Pi. Box86 lets you run x86 Linux programs (such as games) on non-x86 Linux, like ARM (host system needs to be 32bit little-endian). Because Box86 uses the native versions of some \"system\" libraries, like libc, libm, SDL and OpenGL, it's easy to integrate and use, and performance can be surprisingly high in some cases. Box86 now integrates a DynaRec (dynamic recompiler) for the ARM platform, providing a speed boost between 5 to 10 times faster than only using the interpreter. btop++ https://github.com/aristocratos/btop - Thanks to: - aristocratos and all contributers. - Crilum on GitHub for writing the scripts. ARM32/ARM64 Awesome terminal resource monitor and task manager, similar to htop. Run from Terminal: btop btop shows CPU, memory, network, and disk usage, along with a task manager. btop is also very user customizable, with different layouts and ways of displaying CPU, memory, network and disk usage. If you want to look at screenshots of btop, go to the GitHub README. Clam Antivirus https://gitlab.com/dave_m/clamtk ARM32/ARM64 Open-source antivirus for your pi Run with the command \"clamscan\" or go to Menu > Utility > ClamTK. \u2219 Open source \u2219 Install it, set a schedule and forget it \u2219 Scans your entire filesystem \u2219 Moves suspicious files to quaratine \u2219 Has a GUI to control it CommanderPi https://github.com/Jack477/CommanderPi ARM32/ARM64 Easy RaspberryPi4 GUI system managment Using CommanderPi, you can change overclock settings, bootloader settings, switch kernels, and view performance diagnostics. To run: Menu -> Accessories -> CommanderPi To run in a terminal: /home/pi/CommanderPi/src/start.sh Disk Usage Analyzer https://wiki.gnome.org/Apps/DiskUsageAnalyzer - Botspot Package app Ever wonder where you put that big file, or why your SD card is full? Now you can, with a glance at a pie chart. To run: Menu -> System Tools -> Disk Usage Analyzer To run in a terminal: baobab FF Multi Converter https://sites.google.com/site/ffmulticonverter/ - Thanks to Crilum on GitHub for writing the scripts. Thanks to ilstad on GitHub and all Contributors for creating FF Multi Converter! ARM32/ARM64 FF Multi Converter is a simple graphical application for Linux which enables you to convert audio, video, image and document files. It uses FFmpeg for audio/video files, the ImageMagick software suite for image conversions and unoconv for document files. The goal of FF Multi Converter is to gather the most popular multimedia types in one application and provide conversion options for them easily through a user-friendly graphical interface. Run from Menu: Menu -> Accesories -> FF Multi Converter Run from Terminal: ffmulticonverter Flameshot https://flameshot.org/ - Flameshot.org for creating the tool + all github contributors CleanMachine1 for the install scripts and suggestion Itai-Nelken for finding the .deb files for installing Chunky-Milk for hosting the .deb file in their Github ARM32/ARM64 A simple tool to take screenshots of your screen or just parts of the screen. It is similar to Microsoft's Snipping Tool. To launch: Menu -> Graphics -> Flameshot To use: find the flameshot icon in your taskbar (system tray) and click it to open Flameshot. To run in a terminal: flameshot Geekbench https://www.geekbench.com/ ARM32/ARM64 Geekbench 5 is a cross-platform benchmark that measures your system's performance with the press of a button. How will your mobile device or desktop computer perform when push comes to crunch? How will it compare to the newest devices on the market? Find out today with Geekbench 5. To run in terminal: geekbench Github-CLI https://cli.github.com/ - Added to pi-apps by Itai-Nelken ARM32/ARM64 gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code. to run (terminal only): gh GParted https://gparted.org - Botspot Package app Graphically manage disk partitions With GParted you can resize, copy, and move partitions without data loss, enabling you to: - Grow or shrink your C: drive - Create space for new operating systems - Attempt data rescue from lost partitions To run: Menu -> System Tools -> GParted To run in a terminal: sudo gparted Guake Terminal http://guake-project.org/ - Botspot ARM32/ARM64 Guake is a top-down terminal, inspirated by the famous terminal used in Quake. You can show and hide your terminal with a single key stroke, execute a command, and then go back to your previous task without breaking your workflow. To run: Press F12. (Guake runs automatically on startup) To run manually: Menu -> System Tools -> Guake Terminal To run in a terminal: guake Https File Server http://www.rejetto.com/hfs/?f=intro ARM32 ONLY Simple file-sharing webserver. Other computers on your local network can connect to your computer from the web browser and download files you share. Or, you can enable port forwarding on your router so that anyone on the Internet can download your files. This app uses Wine to run a windows exe file. To launch: Menu -> Applications -> HTTPS File Server Imager https://www.raspberrypi.org/blog/raspberry-pi-imager-imaging-utility - Botspot Package app Raspberry Pi's official SD card imaging utility. This includes many features and customizations you can make to the image before flashing, and is overall very reliable. To run: Menu -> Accessories -> Imager To run in terminal: rpi-imager KeePassX https://github.com/keepassxreboot/keepassxc - @ryanfortner (GitHub) for the scripts @raspbian-addons maintainers for the deb ARM32/ARM64 KeePassXC is a modern, secure, and open-source password manager that stores and manages sensitive information. Run via the Main Menu > Accessories > KeePassXC Mission Planner https://ardupilot.org/planner/ - Botspot made this app. ARM32/ARM64 Software used to control autonomous vehicles. Mission Planner is a free, open-source ground station for communicating with autonomous aircraft, vehicles, or boats running Ardupilot firmware. It's used to monitor such vehicles, view logs, and create waypoint missions. Nautilus https://wiki.gnome.org/Apps/Files - Botspot Package app Feature-rich file manager for the GNOME desktop To run: Menu -> Accessories -> Nautilus To run in terminal: nautilus Node.js https://nodesource.com/ - Script by ilobilo Script improved by Itai-Nelken ARM32/ARM64 JavaScript code outside a web browser. Node.js is used for all npm packages and is the foundation of Electron. As usual, this app will keep it updated. Pi-Apps Terminal Plugin (bash) Created and added to pi-apps by Itai-Nelken ARM32/ARM64 Pi-apps terminal is a script that lets you use pi-apps from the terminal, its written in bash. It has all the commands you will ever need: 'install' - install a app available in pi-apps. 'remove' - uninstall a app installed by pi-apps (uninstall also works). 'multi-install' - install multiple apps. 'multi-remove' - uninstall multiple apps (multi-uninstall also works). 'list-all' - list all the apps in pi-apps (note that this will also list apps that are not available for your OS). 'list-installed' - list all the apps installed by pi-apps. 'list-uninstalled' - list all the uninstalled apps. 'list-corrupted' - list all the corrupted apps. 'search' - usage: search \"search-term\". search a app available in pi-apps (note that this will show results from the description of the 'apps as well as their name). 'website' - usage: website \"app-name\". print the website of a app available in pi-apps. 'update' - update all pi-apps components. 'update-apps' - update all pi-apps apps only. 'gui' - launch pi-apps regularly. and it makes life easier by eliminating the use of quotes for apps with a space in their name (unless you are using 'multi-install' or 'multi-uninstall'). Pi-Apps Terminal Plugin (python) https://github.com/techcoder20/PiAppsTerminalAdvanced - App made by and added to pi-apps by RPICoder ARM32 ONLY This is a terminal version of pi apps but with more features. Usage pi-apps [argument] Available Arguments: \"list-all\" Prints the list of available apps that are installable \"list-installed\" Prints all installed apps \"list-uninstalled\" Prints all uninstalled apps \"install [appname]\" Install any app available in pi-apps \"uninstall [appname]\" Uninstall any app available in pi-apps \"search [appname]\" Search for a app in pi apps \"website [appname]\" Prints website for app \"update\" Update pi-apps \"gui\" Launches gui for pi-apps Run \"pi-apps help\" to get this information PiGro https://github.com/actionschnitzel/PiGro-Aid- ARM32/ARM64 PiGro is a program designed to make all Debian-based distributions easier to use on the Pi. The most common terminal commands can be executed with one click. piKiss https://github.com/jmcerrejon/PiKISS ARM32 ONLY A bunch of scripts with a menu to make your life easier. To run: Menu -> System Tools -> PiKiss To run in a terminal: ~/piKiss/piKiss.sh \u2219 Easy system configuration \u2219 Ability to install your favourite games like Half Life \u2219 Emulators galore! \u2219 Install apps like OBS and Cool-Retro-Term! \u2219 AND MUCH MORE! Pi Power Tools https://github.com/Botspot/Pi-Power-Tools ARM32/ARM64 Easily edit RaspiOS image files with a suite of useful tools. All features: Advanced Mount, Shrink, Expand, Flash, Boot in a VM, Download, Mount (View), Edit partitions, and Repair. To run: Menu -> Accessories -> Pi Power Tools To run in a terminal: ~/Pi-Power-Tools/home PiSafe https://github.com/RichardMidnight/pi-safe ARM32/ARM64 Create compressed image files. Flash SD cards from a disk image. Many file types supported. To run: Menu -> Accessories -> PiSafe To run in a terminal: pisafe QEMU https://www.qemu.org/ - Added to Pi-Apps by Itai-Nelken debs compiled and packaged using QEMU2DEB (tool by Itai-Nelken) by ryanfortner. ARM32/ARM64 QEMU is a generic and open source machine emulator and virtualizer. Latest version of QEMU, Not outdated like the repository's QEMU. If you ever had trouble using the repository's QEMU, this version will work way better. (for example the MacOS 9 dock doesn't appear using the repository's QEMU). Raspi2png https://github.com/AndrewFromMelbourne/raspi2png ARM32/ARM64 Takes a screenshot of the framebuffer. Useful for overlay applications, like Minecraft or VLC, as this will capture them properly. Run in a terminal: raspi2png The resulting image will be saved to /home/pi/snapshot.png Scrcpy https://github.com/Genymobile/scrcpy ARM32/ARM64 Screen mirror over USB or wireless ADB Screenshot https://apps.gnome.org/app/org.gnome.Screenshot - Botspot Package app Simple interface for capturing screenshots, similar to the Windows Snipping Tool. To run: Menu -> Accessories -> Screenshot To run in terminal: gnome-screenshot Snapdrop https://github.com/RobinLinus/snapdrop - Added by @ryanfortner (Github) ARM32/ARM64 Share files with nearby devices on the local network. Inspired by Apple's Airdrop. To run: Menu -> Internet -> Snapdrop To use: Open a web browser on the other computer/smartphone and go to snapdrop.net Now drag and drop files to the website, and the other device will see the files and download them. Snap Store https://snapcraft.io/store - Installation script and made by RPICoder ARM32/ARM64 Snaps are app packages for desktop, cloud and IoT that are easy to install, secure, cross\u2010platform and dependency\u2010free. Snaps are discoverable and installable from the Snap Store, the app store for Linux with an audience of millions. Synaptic https://www.lifewire.com/guide-to-synaptic-package-manager-220570y - Botspot Package app Advanced APT-package-management tool To run: Menu -> Preferences -> Synaptic Package Manager To run in terminal: sudo synaptic SysMonTask https://github.com/KrispyCamel4u/SysMonTask - @KrispyCamel4u (GitHub) for the program @ryanfortner (GitHub) for the scripts ARM32/ARM64 Linux system monitor similar to the Windows task manager, written in Python. Run via the Main Menu > System Tools > SysMonTask. Sysmon https://github.com/t0xic0der/sysmon - @t0xic0der on GitHub for the creation of the app @ryanfortner on GitHub for the scripts ARM32/ARM64 Monitor your Raspberry Pi using a web browser on another computer. This is a background service that hosts a website at <your Pi's IP address>:6969. Using any computer on your local network, you can go to that website and view many useful statistics. (And some useless ones too) For testing purposes, you can look at the website from the Pi itself by launching Chromium browser and going to http://localhost:6969 As mentioned earlier, the website is only visible to computers in the local network. Temps https://github.com/musicpro/temps - Thanks to Crilum on GitHub for making the scripts. Thanks to jackd248 on GitHub for the original temps. Thanks to promusic on GitHub for forking and continuing development on this awesome app! ARM32/ARM64 Temps is a modern and minimal menubar application based on Electron with actual weather information and forecast. Run from: Menu -> Accessories -> Temps or from Terminal: temps Timeshift https://github.com/teejee2008/timeshift - app created by: teejee2008 https://github.com/teejee2008/ Added to pi-apps by: Itai-Nelken https://github.com/Itai-Nelken/ https://bit.ly/raspberry-pi-stuff-YT ARM32/ARM64 System restore tool for Linux that provides functionality similar to the System Restore feature in Windows and the Time Machine tool in Mac OS. System restore tool for Linux. Creates filesystem snapshots using rsync+hardlinks, or BTRFS snapshots. Supports scheduled snapshots, multiple backup levels, and exclude filters. Snapshots can be restored while system is running or from Live CD/USB. to run from terminal: timeshift tldr https://github.com/dbrgn/tealdeer - Ported to pi-apps by Raspberry Pi News on youtube Made by the community at https://github.com/tldr-pages/tldr ARM32/ARM64 The tldr project is a collection of community-maintained help pages for command-line tools, that aims to be a simpler, more approachable complement to traditional man pages. Run it by typing \"tldr <command>\" into terminal. Maybe you are new to the command-line world? Or just a little rusty? Or perhaps you can't always remember the arguments to lsof, or tar? It also is more digestable than man pages which blasts pages of useless stuff at you every time you use it. Update Buddy https://github.com/Botspot/update-buddy ARM32/ARM64 Automatically check for APT updates on boot. If anything can be upgraded, asks permission to upgrade. To run: should run automatically on startup. To run in a terminal: ~/update-buddy/onstartup.sh USBImager https://bztsrc.gitlab.io/usbimager/ ARM32/ARM64 A very minimal GUI app that can write compressed disk images to USB drives. USBImager is a very useful and minimal app that works like etcher and Raspberry Pi imager but needs less resources, (it's less then 400kb). To run from terminal, type: usbimager. VeraCrypt https://www.veracrypt.fr/en/Documentation.html - nielsbaloe on Github suggested this be added. Botspot added it. ARM32 ONLY Open source disk encryption software - Creates a virtual encrypted disk within a file and mounts it as a real disk. - Encrypts an entire partition or storage device such as USB flash drive or hard drive. - Encrypts a partition or drive where Windows is installed (pre-boot authentication). - Encryption is automatic, real-time(on-the-fly) and transparent. - Parallelization and pipelining allow data to be read and written as fast as if the drive was not encrypted. - Encryption can be hardware-accelerated on modern processors. - Provides plausible deniability, in case an adversary forces you to reveal the password: Hidden volume (steganography) and hidden operating system. - More information about the features of VeraCrypt may be found in the documentation. Windows Flasher https://github.com/Botspot/wor-flasher - Botspot ARM32/ARM64 Install Windows 10 or Windows 11 on a Raspberry Pi SD card. This tool is a 100% legal way to use any Debian or Ubuntu Linux operating system to flash a RPi's SD card with the necessary files to run Windows 10 or 11. Usage is simple: - Choose an operating system version. (Windows 11, Windows 10, Custom version) - Choose what model Pi will be running Windows. (RPi4 or RPi3) - Choose a language. - Choose a storage drive to flash. - Click Flash. It's as simple as that. WoR-flasher takes care of the rest - downloading hundreds of files from Microsoft, generating a Windows image with them, importing the custom RPi drivers, enabling the WinPE environment, and much more. When finished, WoR-flasher will tell you exactly what to do next. To run: Menu -> Accessories -> WoR-Flasher To run the graphical interface in a terminal: ~/wor-flasher/install-wor-gui.sh To run the command-line interface in a terminal: ~/wor-flasher/install-wor.sh If you encounter problems, we recommend you run WoR-flasher in a terminal to catch any errors. Wine (x86) https://www.winehq.org/ - Script by Itai-Nelken and Botspot ARM32 ONLY Run x86 Windows apps with a box86-emulated version of x86 wine. To run: wine path/to/file.exe To configure wine: go to 'Wine configuration' in main menu or type in terminal: wine winecfg Not all Windows applications will work under Wine. It's a good idea to check online if your program can run, or if something can be tweaked to make it work. Note: the applications installed with wine will appear under the wine category in the main menu, and they will stay there even after uninstalling wine. Need support with running a game or app with wine and box86? Ask it on the Pi Labs Discord: https://discord.gg/JKNQXprqUd","title":"Apps List"},{"location":"apps-list/#apps-list","text":"","title":"Apps List"},{"location":"apps-list/#appearance","text":"","title":"Appearance"},{"location":"apps-list/#color-emoji-font","text":"ARM32/ARM64 Installs two fonts to display all emojis in the Unicode Emoji 13.0. This installs Noto Color Emoji font. To test if it works, go to: https://tmh.conlang.org/emoji-language/all-emoji.html","title":" Color Emoji font"},{"location":"apps-list/#conky","text":"https://github.com/Botspot/rpi_conky ARM32/ARM64 Monitors CPU, RAM, disk usage, and more. This sits on your desktop, refreshing once a second, with pretty graphs showing you all you need to know. To run: it should autostart on boot. To run in a terminal: conky","title":" Conky"},{"location":"apps-list/#conky-rings","text":"https://github.com/Botspot/rpi_conky/tree/master/conky_rings - phoenixbyrd for the files ryanfortner for the scripts Botspot for coloring the theme ARM32/ARM64 Animated gauges and graphs of your system, on your desktop. Displays system uptime, core-specific CPU usage, CPU speed, CPU temperature, top 5 processes by CPU usage, storage usage for boot and root partitions, RAM usage, SWAP usage, top 5 processes by RAM usage, and describes the current Linux environment.","title":" Conky Rings"},{"location":"apps-list/#cool-retro-term","text":"https://github.com/Swordfish90/cool-retro-term ARM32/ARM64 Simulates an old CRT terminal. This is fully hardware accelerated as long as your Fake KMS GPU driver is enabled. Yes, it's a usable pi@raspberrypi terminal emulator. To run: Menu -> System Tools -> Cool Retro Term To run in terminal: ~/cool-retro-term/cool-retro-term","title":" Cool Retro Term"},{"location":"apps-list/#edex-ui","text":"https://github.com/Botspot/eDEX-UI-RPi ARM32/ARM64 Futuristic hacker terminal Inspired from Hollywood, this terminal is beautiful to look at and will impress your friends. It's a fully-functional bash terminal, system monitor, file manager, and on-screen keyboard, all in one fullscreen window. Oh, and it has sound effects. To run: Menu -> System Tools -> eDEX-UI 2.2.7. This new version loads in about 10 seconds! (instead of 2 minutes like Novaspirit's old version) To exit eDEX-UI, press Alt+F4, or run this command in the terminal: exit Change settings with Ctrl+Shift+S. View all keyboard shortcuts with Ctrl+Shift+K. Novaspirit Tech made an excellent walkthrough video a while ago: https://www.youtube.com/watch?v=DJOAmYlDQuM","title":" eDEX-UI"},{"location":"apps-list/#geany-dark-mode","text":"https://github.com/codebrainz/geany-themes - Botspot. Oh yeah. ARM32/ARM64 Proper appearance theme for the Geany text editor. Geany's default color scheme looks horrible. Fortunately, this app will make it look good. By default, this will apply the \"spyder-dark\" theme, (Botspot's favorite!), but it will also install many other themes to try out as well. To switch themes in Geany: View -> Change Color Scheme.","title":" Geany Dark Mode"},{"location":"apps-list/#libreoffice-ms-theme","text":"https://github.com/Botspot/libreoffice-ms-theme - Botspot made this script and theme. ARM32/ARM64 Make Libreoffice to look like Microsoft office - icon theme and tabbed interface. The icon theme was obtained from here: https://www.deviantart.com/charliecnr/art/Office-2013-theme-for-LibreOffice-512127527 And the tabbed interface is a hidden feature within Libreoffice. Currently, the tabbed interface works for Calc, Impress, and Writer. Base and Math don't support it, and it doesn't display correctly on Draw for some reason.","title":" Libreoffice MS theme"},{"location":"apps-list/#lightpad","text":"https://github.com/libredeb/lightpad - Installation Script Made By RPICoder App Added To Pi-Apps by RPICoder ARM32/ARM64 LightPad is a lightweight, simple and powerful application launcher. To run: Menu -> Accessories -> Lightpad To run in a terminal: com.github.libredeb.lightpad","title":" Lightpad"},{"location":"apps-list/#mac-os-theme","text":"https://github.com/techcoder20/MacOSBigSurThemeConverter - App Made By And Added To Pi-Apps By RPI Coder ARM32 ONLY Realistic Light/Dark Mac OS Big Sur appearance theme. Uses XFCE desktop. This is a bash script that will make your plain Raspberry Pi OS LXDE desktop look similar to MacOSBigSur. You can switch between light and dark themes using the themeconverter. To run: Menu -> Accessories -> ThemeConverter To run in a terminal: themeconverter Uninstalling this app should restore all of your original theme configuration. If something breaks due to this theme, please report it.","title":" Mac OS Theme"},{"location":"apps-list/#oomox-theme-designer","text":"https://github.com/themix-project/oomox ARM32/ARM64 A tool to customize icons, xrdb and GTK themes. Graphical application for generating different color variations of Oomox (Numix-based) and Materia (ex-Flat-Plat) themes (GTK2, GTK3, Cinnamon, GNOME, Openbox, Xfwm), Archdroid, Gnome-Color, Numix, Papirus and Suru++ icon themes. You can apply your themes in lxappearance. To run: Menu -> Graphics -> Oomox Theme Designer To run in a terminal: oomox-gui","title":" Oomox Theme Designer"},{"location":"apps-list/#powerline-shell","text":"https://github.com/techcoder20/RPI-PowerlineShell-Installer.git - Installation Script Created By RPICoder Added To Pi Apps By Botspot ARM32/ARM64 A beautiful and useful prompt generator for Bash, ZSH, Fish, and tcsh: -Shows some important details about the git/svn/hg/fossil branch -Changes color if the last command exited with a failure code -If you're too deep into a directory tree, shortens the displayed path with an ellipsis -Shows the current Python virtualenv environment -It's easy to customize and extend.","title":" Powerline-Shell"},{"location":"apps-list/#ulauncher","text":"https://ulauncher.io/ - RPiCoder on Discord recommended this. Botspot made the scripts. ARM32/ARM64 All-in-one application launcher, Google search engine, calculator, file manager... This is the best app launcher I've ever seen, though it can be a bit slow when searching. - Botspot","title":" Ulauncher"},{"location":"apps-list/#windows-10-theme","text":"https://github.com/Botspot/Windows-10 ARM32/ARM64 Make Raspberry Pi OS look as close to Windows 10 as possible. Installs an icon theme, GTK theme, openbox theme, mouse cursor theme, window shadows, window fading, desktop background and custom panel.","title":" Windows 10 Theme"},{"location":"apps-list/#windows-screensavers","text":"https://github.com/Botspot/Screensavers - Botspot ARM32 ONLY 14 Windows screensavers that run well on Raspberry Pi. Once installed, you can launch Botspot's Screensavers GUI from: Menu -> Preferences -> Windows Screensavers. To run in terminal: ~/Screensavers/gui Preview a screensaver, change its settings, and enable it to run after a specified duration of inactivity. The screensaver will not start while audio is playing. Note: If you don't have Wine installed, this app will install it for you. In addition to the Windows Screensavers, Botspot's Screensaver GUI also allows convenient installation of GPU-accelerated Xscreensaver, preset to enable the best ones out of 230 screensavers.","title":" Windows Screensavers"},{"location":"apps-list/#xsnow","text":"https://www.ratrabbit.nl/ratrabbit/xsnow/ - Thanks to Willem Vermin for developing this project. ARM32/ARM64 This turns your desktop wallpaper into an animated winter wonderland! Features falling snowflakes, flying birds, scenery like trees and deer, the moon, Santa, flapping birds, and more. Over time, snow will begin to collect on the top of your windows. To run: Menu -> Games -> xsnow To run in terminal: xsnow","title":" XSnow"},{"location":"apps-list/#editors","text":"","title":"Editors"},{"location":"apps-list/#arduino","text":"https://www.arduino.cc/en/main/software ARM32/ARM64 Latest version of Arduino IDE. Not outdated like the repository's Arduino IDE. Use this to flash your code to Arduino microprocessors. To run: Menu -> Programming -> Arduino IDE. To run in a terminal: /home/pi/arduino-1.8.13/arduino","title":" Arduino"},{"location":"apps-list/#blockbench","text":"https://github.com/JannisX11/blockbench - JannisX11 (GitHub) for creating the program ryanfortner (GitHub) for writing scripts, and hosting the debs cycool29 (GitHub) for compiling debs ARM32/ARM64 Blockbench is a free, modern model editor for low-poly and boxy models with pixel art textures. Models can be exported into standardized formats, to be shared, rendered, 3D-printed, or used in game engines. There are also multiple dedicated formats for Minecraft Java and Bedrock Edition with format-specific features.","title":" BlockBench"},{"location":"apps-list/#blockpi","text":"https://github.com/alienzhangyw/BlockPi - Botspot made the app's install scripts ARM32/ARM64 Create python programs using drag-n-drop blocks A visual programming editor app for Raspberry Pi, built on Google Blockly, made for RPi users or kids to learn coding. To run: Menu -> Programming -> BlockPi To run in a terminal: /opt/BlockPi/blockpi","title":" BlockPi"},{"location":"apps-list/#boxy-svg","text":"https://github.com/Botspot/Boxy-SVG-RPi - Shout-out to ItzCutePikachu for figuring out how to remove the annoying \"Boxy SVG will stop working\" pop-up from the javascript. ARM32/ARM64 The best vector graphics image editor for Raspberry Pi. Finally, the full version of Boxy SVG has arrived! This installs the Boxy SVG offline Chrome App onto your existing Chromium Browser. Performance is excellent, and I (Botspot) have been using it on my RPi for for all graphics editing. (Including the Pi-Apps logo!) If you have a problem using Boxy SVG, please report it on Botspot's github page, not to the Boxy SVG website! If there's too many RPi-based bug reports, the Boxy SVG dev may withdraw his permission for it to be on Pi-Apps, and nobody wants that to happen. Note: also see the Inkscape app.","title":" Boxy SVG"},{"location":"apps-list/#codex","text":"https://github.com/jcv8000/Codex ARM32/ARM64 A free note-taking software for programmers and Computer Science students. To run: Menu -> Accessories -> Codex","title":" Codex"},{"location":"apps-list/#cura","text":"https://community.ultimaker.com/topic/28746-experimental-cura-build-for-raspberry-pi-4-now-available/ ARM32/ARM64 Takes a 3D model and slices it for use in a 3D printer. To run: Menu -> Programming -> Ultimaker Cura To run in a terminal: ~/Cura.AppImage","title":" Cura"},{"location":"apps-list/#drawing","text":"https://github.com/maoschanz/drawing - Botspot ARM32/ARM64 Simple program used to hand-draw png images. To run: Menu -> Graphics -> Drawing To run in terminal: drawing Note: This serves a different purpose than Microsoft Paint. If you want a Paint-style tool, install Kolourpaint: sudo apt install kolourpaint","title":" Drawing"},{"location":"apps-list/#eagle-cad","text":"http://eagle.autodesk.com/eagle/software-versions/1 - Botspot made this app. ARM32 ONLY Design printed circuit boards. This is Eagle CAD's last 32-bit Linux release (7.7.0), emulated using Box86. Subsequent Eagle releases dropped 32-bit support. To run: Menu -> Programming -> Eagle To run in a terminal: eagle","title":" Eagle CAD"},{"location":"apps-list/#freecad","text":"https://scruss.com/blog/2020/02/16/freecad-on-raspberry-pi-4/ - .deb compiled by @ryanfortner (GitHub) ARM32 ONLY 3D designer software. Unlike the repository's version of FreeCAD, this one actually works. Thanks to @ryanfortner, the FreeCAD app is now a deb, and installs in a few minutes instead of many hours! To run: Menu -> Graphics -> FreeCAD To run in a terminal: FreeCAD","title":" FreeCAD"},{"location":"apps-list/#gimp","text":"https://www.gimp.org/ - Made by The GIMP Team Added to Pi Apps by Lightstrike on Discord Package app Create images and edit photographs GIMP stands for \"GNU Image Manipulation Program\". Whether you are a graphic designer, photographer, illustrator, or scientist, GIMP provides you with sophisticated tools to get your job done. You can further enhance your productivity with GIMP thanks to many customization options and 3rd party plugins. To run: Menu -> Graphics -> GNU Image Manipulation Program To run in terminal: gimp","title":" GIMP"},{"location":"apps-list/#inkscape","text":"https://inkscape.org - 1Spinne in issue #1262 Package app Popular free vector graphics editor Whether you are an illustrator, designer, web designer or just someone who needs to create some vector imagery, Inkscape is for you! Flexible drawing tools Broad file format compatibility Powerful text tool Bezier and spiro curves Note: Also see the Boxy SVG tool.","title":" Inkscape"},{"location":"apps-list/#intellij-idea","text":"https://www.jetbrains.com/idea/ - Thanks to GlacierPark19 for suggesting this app be added. Botspot made it. ARM32/ARM64 IntelliJ IDEA is an IDE designed to maximize developer productivity. It does the routine and repetitive tasks for you by providing clever code completion, static code analysis, and refactorings, and lets you focus on the bright side of software development, making it not only productive but also an enjoyable experience.","title":" Intellij IDEA"},{"location":"apps-list/#jgrasp-ide","text":"https://www.jgrasp.org/index.html - Botspot made this app. ARM32/ARM64 An IDE with visualizations for improving software comprehensibility. This IDE is used by many learning institutions and colleges for their classes.","title":" jGRASP IDE"},{"location":"apps-list/#kolourpaint","text":"https://apps.kde.org/kolourpaint/ - Botspot Package app An easy-to-use paint program. KolourPaint is a simple painting program to quickly create raster images. It is useful as a touch-up tool and simple image editing tasks. Features: - Support for drawing various shapes: lines, rectangles, rounded rectangles, ovals and polygons - Curves, lines and text - Colour picker - Selections - Rotation, monochrome, redaction and other advanced effects To run: Menu -> Graphics -> Kolourpaint To run in terminal: kolourpaint","title":" Kolourpaint"},{"location":"apps-list/#lego-digital-designer","text":"https://github.com/Botspot/lego-digital-designer-rpi - Botspot ARM32 ONLY Play with virtual Lego blocks and create your own plans! This is Lego's official (discontinued) brick design program. With it, you can build your own sets within the editor and paint the pieces any color you wish. Afterwards, you can generate step-by-step building plans and print them out. Or you could place your creation into a desert background and take a picture of it to share with friends. This program runs extremely well on RPi. The only problem I (Botspot) could find was the sound effects don't work.","title":" Lego Digital Designer"},{"location":"apps-list/#libreoffice","text":"https://www.libreoffice.org - Botspot Package app Free office suite including a word editor, slideshow, spreadsheet, database, and image editor To run: Menu -> Office -> LibreOffice To run in terminal: libreoffice To make it look and feel like Microsoft Office, see the \"Libreoffice MS Theme\" app!","title":" LibreOffice"},{"location":"apps-list/#librepcb","text":"https://librepcb.discourse.group/t/how-to-install-librepcb-on-a-raspberry-pi/212 ARM32 ONLY Develop printed circuit boards.","title":" LibrePCB"},{"location":"apps-list/#linuxcnc","text":"http://linuxcnc.org - Thanks to the LinuxCNC community for creating LinuxCNC Thanks to Crilum on GitHub for making the scripts. ARM32 ONLY LinuxCNC controls CNC machines. It can drive milling machines, lathes, 3D printers, laser cutters, plasma cutters, robot arms, hexapods, and more. How to run: Menu -> Other -> LinuxCNC In Terminal: linuxcnc LinuxCNC is software that runs on Linux, on most standard PCs, that can interpret G-code and run a CNC machine. It was originally developed on a milling machine, but support was added for lathes and many other types of machine. It can be used with mills, lathes, plasma cutters, routers, robots, and so on.","title":" LinuxCNC"},{"location":"apps-list/#nixnote2","text":"https://github.com/baumgarr/Nixnote2 - Botspot Package app Take notes, organize your schedule, and save websites with this offline and open-source Evernote client. To run: Menu -> Internet -> NixNote2 To run in a terminal: nixnote2","title":" NixNote2"},{"location":"apps-list/#notepad","text":"https://notepad-plus-plus.org/ - App added to pi-apps by RPICoder ARM32 ONLY Notepad++ is a free source code editor and Notepad replacement that supports several languages. To Run: Menu -> Accessories -> Notepad++ This app runs with the help of box86 and wine.","title":" Notepad ++"},{"location":"apps-list/#openscad","text":"http://www.openscad.org/ https://github.com/koendv/openscad-raspberrypi ARM32/ARM64 OpenSCAD is software for creating solid 3D CAD models. Unlike most free software for creating 3D models, OpenSCAD does not focus on the artistic aspects of 3D modelling but instead on the CAD aspects. OpenSCAD is more suitable for creating 3D models of machine parts but perhaps not when creating computer-animated movies. OpenSCAD is not an interactive modeller. Instead OpenSCAD is something like a 3D-compiler that reads in a script file that describes the object and renders the 3D model from this script file. This gives designers full control over the modelling process and enables them to easily change any step in the modelling process or make designs that are defined by configurable parameters. To run: Menu -> Graphics -> OpenSCAD To run in a terminal: OpenSCAD.AppImage","title":" OpenSCAD"},{"location":"apps-list/#pinta","text":"https://www.pinta-project.com/ - Botspot Package app A powerful painting program including numberous adjustments, drawing tools, multiple layers, and a flexible interface. To run: Menu -> Graphics -> Pinta To run in a terminal: pinta","title":" Pinta"},{"location":"apps-list/#processing-ide","text":"https://processing.org/ - added by pi-dev500 ARM32/ARM64 Simple Java IDE Processing is an IDE + Programming Language used for Visual Arts. It is an Open-Source and Free Software (FOSS) which is built from Java and is used to create graphics. To run: Menu -> Programming -> Processing IDE To run in a terminal: ~/.local/share/processing-3.5.3/processing","title":" Processing IDE"},{"location":"apps-list/#prusaslicer","text":"https://github.com/davidk/PrusaSlicer-ARM.AppImage ARM32/ARM64 Takes a 3D model and slices it for use in a 3D printer.","title":" PrusaSlicer"},{"location":"apps-list/#pycharm-ce","text":"https://www.jetbrains.com/pycharm/ - Thanks to gam3t3chelectronicshobbyhouse a.k.a 'Gam3t3ch' for \"Installing PyCharm on Raspberry Pi 4\" from element14. Also, fabianmendes for introducing it into pi-apps. ARM32/ARM64 Python Community Edition IDE for Professional and Educational Developers. To run: Menu -> Programming -> Pycharm Community Edition To run in a terminal: /opt/pycharm-community/bin/pycharm.sh You must configure the IDE to run each script (\"py\" file), or create a new environment. For Educational purposes, the \"EDUtools\" plugin can be installed. Go to the right corner from the Pycharm start up portal: Configurate > Plugins > Search for: EDUtools > Install it and restart the IDE. Then you will able to select \"Learn and Teach\" for courses.","title":" Pycharm CE"},{"location":"apps-list/#remarkable","text":"https://remarkableapp.github.io - Added to Pi-Apps by Itai-Nelken. Thanks to seiferteric on GitHub for providing the DEB package fix. ARM32/ARM64 A fully featured Markdown editor for Linux. Remarkable has many features including: - Live Preview with Synchronized Scrolling - Syntax Highlighting - GitHub Flavored Markdown Support - HTML and PDF Export - Dialogs for adding images, links and tables - Styles - Custom CSS Support - Keyboard Shortcuts","title":" Remarkable"},{"location":"apps-list/#scratch-2","text":"https://github.com/Botspot/scratch2 - Botspot ARM32 ONLY Scratch 2 was removed from RPiOS in January. Install it back with this app! Scratch 2 is significantly faster than Scratch 3. It uses far less CPU, and generally will run better than Scratch 3 on older Pies. To run: Menu -> Programming -> Scratch 2. To run in a terminal: scratch2","title":" Scratch 2"},{"location":"apps-list/#scratch-3","text":"https://scratch.mit.edu - Botspot Package app Enjoy learning computer programming with drag-n-drop blocks! This is Raspberry Pi's official electron build of Scratch 3 and it runs offline. To run: Menu -> Programming -> Scratch 3 To run in a terminal: /usr/lib/scratch3/scratch-desktop Note: Consider trying Turbowarp or Scratch 2 - both run faster than this version.","title":" Scratch 3"},{"location":"apps-list/#shotwell","text":"https://shotwell-project.org/doc/html/ - Botspot Package app Organize, edit, and publish your photos. To run: Menu -> Graphics -> Shotwell To run in terminal: shotwell","title":" Shotwell"},{"location":"apps-list/#stackedit","text":"https://stackedit.io/ - Added to pi-apps by Itai-Nelken. webapps compiled by Itai-Nelken using nativefier. nativefier by jiahaog. ARM32/ARM64 Full-featured, open-source Markdown editor. StackEdit uses the same markdown library as Stack Overflow and is fully compatible with Github README.md files as well. This is Botspot's preferred tool to write the README for all his repositories. To run: Menu -> Programming -> StackEdit To run in a terminal: ~/stackedit/StackEdit","title":" StackEdit"},{"location":"apps-list/#sublime-text","text":"https://www.sublimetext.com/ - Added to pi-apps by Itai Nelken ARM32/ARM64 Cross-platform source code editor with a Python application programming interface. It natively supports many programming languages and markup languages. Additional features can be added with plugins. To run: Menu -> Programming -> Sublime Text This runs Sublime Text v2 with the Box86 emulator.","title":" Sublime Text"},{"location":"apps-list/#turbowarp","text":"https://turbowarp.org/ - App added to pi-apps by Raspberry Pi News (bit.ly/rpnsite) Made by the TurboWarp dev team (https://github.com/TurboWarp/) ARM32/ARM64 Scratch 3 Desktop, but runs much faster. Also known as 'TurboWarp' TurboWarp is a Scratch mod that compiles projects to JavaScript to make them run really fast. Also has dark mode, addons, and more. It even works when you're offline, just like the original Scratch Desktop. To run: Menu -> Programming -> TurboWarp","title":" Turbowarp"},{"location":"apps-list/#visual-studio-code","text":"https://code.visualstudio.com/ - Install script written by RaspberryPiNews on YT Small change to description by CleanMachine1 Original program made by Microsoft ARM32/ARM64 Visual Studio Code is a free source-code editor made by Microsoft. Features include support for debugging, syntax highlighting, intelligent code completion, snippets, code refactoring, and embedded Git It supports most popular coding languages including Python, JavaScript, and more. Note: If you are using Raspberry Pi OS, you don't need to install this app. Just run \"sudo apt install code\" in the terminal. Pi-Apps will still continue to ship VSCode so that non-PiOS users can still have access to it.","title":" Visual Studio Code"},{"location":"apps-list/#vscodium","text":"https://vscodium.com/ - Added to pi-apps by @ryanfortner (Github) ARM32/ARM64 Visual Studio Code builds without the telemetry and tracking. Microsoft's vscode source code is open source (MIT-licensed), but the product available for download (Visual Studio Code) is licensed under this not-FLOSS license and contains telemetry/tracking.","title":" VSCodium"},{"location":"apps-list/#wps-office","text":"https://www.wps.com - Botspot figured out how to instapp WPS Office on PiOS64. Botspot submitted this app to Pi-Apps. ARM64 ONLY This is the Chinese version of Microsoft Office. It is not open source, but works well on PiOS 64, and looks much more polished than Libreoffice or Openoffice.","title":" WPS Office"},{"location":"apps-list/#games","text":"","title":"Games"},{"location":"apps-list/#amiberry","text":"https://github.com/midwan/amiberry/ - Program created by Dimitris Panokostas (midwan) on GitHub. Debian packages created by @ryanfortner (GitHub) Scripts created by @ryanfortner (GitHub) ARM32/ARM64 Amiberry is a well-optimized, high-performance emulator for running Amiga games on low-power ARM boards like Raspberry Pi. Run it via the main Menu > Games > Amiberry.","title":" Amiberry"},{"location":"apps-list/#astromenace","text":"https://github.com/viewizard/astromenace - All contributer in github page added to pi-apps by Painadath samuelpainadath@gmail.com ARM32/ARM64 Immerse into a decisive battle against tons of cunning foes, face the terrifying bosses and protect your homeland throughout 15 diverse levels of the game. The hardcore gameplay of AstroMenace, packed with pure non-stop action, will become a full scale test for your basic instinct of survival.","title":" AstroMenace"},{"location":"apps-list/#chiaki","text":"https://github.com/Fredrum/chiaki/wiki/Chiaki-for-the-Raspberry-Pi - Chiaki software implementation by Florian M\u00e4rkl: https://github.com/thestr4ng3r Raspberry Pi fork implementation by Blueroom VR: https://github.com/Fredrum Added to Pi-Apps by Markieautarkie: https://github.com/Markieautarkie ARM32/ARM64 Chiaki is a free and open source software client which enables PlayStation 4/5 remote play on the Raspberry Pi. Chiaki wiki: https://git.sr.ht/~thestr4ng3r/chiaki Pi fork wiki: https://github.com/Fredrum/chiaki/wiki/Chiaki-for-the-Raspberry-Pi To run: Menu -> Games -> Chiaki To run in a terminal: Chiaki/build/gui/chiaki ----- Usage ----- Once Chiaki is running, you can enter the settings menu (top right) to configure general/stream settings to your liking. Note that stream quality options are limited depending on your console. To connect and use a controller with Chiaki, please refer to the Pi fork wiki. In most cases, Chiaki will automatically detect your console if it's turned on. Otherwise, you can add it manually by pressing the \"+\" icon (top right) and entering your console's IP address. To finalize the registration, two more parameters need to be set. PSN AccountID: In a terminal, enter \"python3 Chiaki/psn-account-id.py\" and follow the instructions. Registration PIN: On a PS4, go to: Settings -> Remote Play -> Add Device; On a PS5, go to: Settings -> System -> Remote Play -> Link Device. You can now double-click your console in Chiaki's main window to start remote play!","title":" Chiaki"},{"location":"apps-list/#descent-1","text":"https://www.dxx-rebirth.com/ ARM32 ONLY D1X-Rebirth - source port of Descent: First Strike from 1995 This package installs the shareware version, if you own the full game you can copy the game data to ~/.d1x-rebirth directory (replacing existing files). To run: Menu -> Games -> Descent 1 To run in a terminal: ~/.d1x-rebirth/d1x-rebirth-rpi -hogdir ~/.d1x-rebirth To exit: select \"Quit\" in the game's main menu.","title":" Descent 1"},{"location":"apps-list/#descent-2","text":"https://www.dxx-rebirth.com/ ARM32 ONLY D2X-Rebirth - source port of Descent 2: Counterstrike from 1996 This package installs the shareware version, if you own the full game you can copy the game data to ~/.d2x-rebirth directory (replacing existing files). To run: Menu -> Games -> Descent 2 To run in a terminal: ~/.d1x-rebirth/d1x-rebirth-rpi -hogdir ~/.d1x-rebirth To exit: select \"Quit\" in the game's main menu.","title":" Descent 2"},{"location":"apps-list/#doom-3","text":"https://github.com/techcoder20/RPIDoom3Installer.git - Script Created By RPI Coder Added To Pi apps by Botspot Testers: Lukefrenner Botspot Nikolay Dubnov ARM32 ONLY Doom 3 is a 2004 horror first-person shooter video game developed by id Software and published by Activision. In this game a massive demonic invasion has overwhelmed the Union Aerospace Corporation's (UAC) Mars Research Facility, leaving only chaos and horror in its wake. As one of only a few survivors, you must fight your way to hell and back against a horde of evil monsters.","title":" Doom 3"},{"location":"apps-list/#godot","text":"https://github.com/hiulit/Unofficial-Godot-Engine-Raspberry-Pi - Credits to Irtexo for putting it on Pi-Apps. Credits to Hiulit for porting it to the Rpi. Credits to Juan Linietsky and Ariel Manzur for creating Godot. ARM32/ARM64 Open Source Game Engine that's run fine on Rpi (for 2d games). For the export instructions for Rpi go to the website. This Software only run on Rpi4 GLES2 Projects are recommended. To run: Menu -> Programming -> Godot To run in a terminal: ~/Godot/godot_3.4-stable_rpi4_editor_lto.bin","title":" Godot"},{"location":"apps-list/#heroes-2","text":"https://github.com/ihhub/fheroes2 ARM32 ONLY Free implementation of Heroes of Might and Magic II game engine. This package installs the shareware version, if you own the full game you can copy the game data to ~/.fheroes2 directory (replacing existing files). To run: Menu -> Games -> Free Heroes 2 To run in a terminal: ~/.fheroes2/fheroes2-rpi","title":" Heroes 2"},{"location":"apps-list/#minecraft-bedrock","text":"https://github.com/ChristopherHX/linux-packaging-scripts/releases/tag/appimage - Install script written by RaspberryPiNews on YT Appimage made by ChristopherHX on Github Program made by everyone at minecraft-linux on Github ARM32/ARM64 Unoffical launcher for Minecraft Bedrock edition NOTE: For better performance and smooth FPS, we recommend an older Bedrock version like 1.16.40 as it doesn't contain renderdragon or RTX code. Run with the menu app \"Minecraft Bedrock Launcher\" or with the command \"GALLIUM_HUD=simple,fps /opt/MCBedrock.AppImage\" \u2219 Sign in with a Google Play account with Minecraft purchased \u2219 Active comunity to ask for help \u2219 FPS Counter mod \u2219 And much more!","title":" Minecraft Bedrock"},{"location":"apps-list/#minecraft-java","text":"https://www.lunarclient.com/ - Lunar Client is developed by MoonsworthLLC The ARM fork of Lunar Client is maintained by gl91306 on Github: https://github.com/gl91306/lunar ARM lwjgl libs uploaded by rpiMike on the Raspberry Pi Forums Install script written by RaspberryPiNews on Youtube/mobilegmYT on Github Scripts re-written by Botspot ARM32/ARM64 Minecraft Java - now supports Microsoft accounts and Optifine! This installs a fork of Lunar Client, with built in Optifine and other mods for maximum out-of-the-box performance. To run: Menu -> Games -> Minecraft Launcher To run in a terminal: ~/lunarassets/lunarclient.AppImage NOTE: For best performance (60 FPS+), we recommend an older version of Minecraft like 1.12.2 or 1.8 Why lunar? - It's easy to use and to setup. - It is well-maintained and has a vibrant support community. - It supports Microsoft and Mojang accounts. - This fork of Lunar for ARM includes Optifine, automatically switches lwjgl libraries (for playing older versions), and includes other optimizations by default. - It's easy to install in a self contained AppImage. Need help? Please open an issue on this repository: https://github.com/gl91306/lunar","title":" Minecraft Java"},{"location":"apps-list/#minecraft-java-multimc5","text":"https://github.com/cobalt2727/L4T-Megascript/blob/master/scripts/games_and_emulators/minecraft_java_multimc.sh - Install script written by theofficialgman based on the version for the L4T Megascript ARM32/ARM64 NOTE: For best performance, we recommend a version like 1.12.2 + Optifine or the latest Minecraft with Optifabric or Sodium/Lithium/Phosphor Fabric Mods. Minecraft Java MultiMC5 for the Raspberry Pi To run: Menu -> Games -> MultiMC To run in a terminal: ~/MultiMC/install/MultiMC Link to the Raspberry Pi Forum Post: https://forums.raspberrypi.com/viewtopic.php?f=78&t=321888 The MultiMC5 Wiki can be found here: https://github.com/MultiMC/MultiMC5/wiki If you need help installing Optifine: https://github.com/MultiMC/MultiMC5/wiki/MultiMC-and-OptiFine the MultiMC5 install script contains OS detection (ubuntu and debian/raspbian based systems supported), and automatic java 8, 11, and 16 download and installation MultiMC5 supports mojang, microsoft account login, and microsoft gamepass support, and minecraft versions from the old beta/alphas all the way up to 1.17+. Fabric and Forge mod loading is supported for the applicable minecraft versions A custom meta repo is used for arm32 and arm64 to provide lwjgl 2.9.4, 3.1.2(fake), 3.1.6, 3.2.1, 3.2.2, and 3.2.3(unused) native libraries. (https://github.com/theofficialgman/meta-multimc) This supports all currently released versions of minecraft. Note: MultiMC5 does not give support for custom builds If you have found a bug and it is re-producible on official MultiMC5 builds, then it can be submitted at https://github.com/MultiMC/MultiMC5/issues. Otherwise, bugs should be submitted to https://github.com/Botspot/pi-apps/issues","title":" Minecraft Java MultiMC5"},{"location":"apps-list/#minecraft-pi-modded","text":"https://discord.com/invite/aDqejQGMMy - Game mods and jMCPIL made by TheBrokenRail#5376 on Discord gMCPIL made by Alvarito050506#8207 on Discord Ported to Pi-Apps by TheBrokenRail#5376 on Discord with a little help from Botspot. ARM32/ARM64 A modded version of Minecraft: Pi Edition with things like survival mode, multiplayer support, and more! To open the launcher: Menu > Games > gMCPIL or jMCPIL, depending on which version you chose at install time. Use the launcher to set up mods and multiplayer. Need help? Consider asking on MCPI Modded's Discord server instead: https://discord.gg/3wXu3xtr Controls: WASD to move Mouse to look around F1 key to hide HUD F5 to switch to 3rd person view Notes: You must be in gamemode survival and have Touch GUI enabled to use Chests, Crafting Tables, etc. To make a crafting table, press \"E\" and then go to the Craft menu in the upper left-hand corner. Click on what you want to craft, then click the big button with all of the stuff needed to craft the item to craft it. Mouse scroll doesn't exist, you need to use your mouse to drag stuff like the crafting menu.","title":" Minecraft Pi (Modded)"},{"location":"apps-list/#ppsspp-psp-emulator","text":"http://ppsspp.org - Added to pi-apps by @ryanfortner (Github) ARM32/ARM64 A PSP emulator that can run PSP games in full HD and can upscale textures also. How to run: Menu > Games > PPSSPP","title":" PPSSPP (PSP emulator)"},{"location":"apps-list/#steam","text":"https://www.tomshardware.com/how-to/raspberry-pi-install-steam ARM32 ONLY This emulates the x86_32bit Linux version of Steam using Box86. To run: Menu -> Games -> Steam","title":" Steam"},{"location":"apps-list/#steam-link","text":"Botspot Package app The Steam Link app brings desktop gaming to your Raspberry Pi. Just pair a controller to your device, connect to a computer running Steam on the same local network, and start playing your existing Steam games. To run: Menu -> Games -> Steam Link To run in a terminal: steamlink","title":" Steam Link"},{"location":"apps-list/#stunt-rally","text":"http://stuntrally.tuxfamily.org/ - Compiled and packaged into a deb by Itai-Nelken. Added to pi-apps by Itai-Nelken. ARM32/ARM64 Racing game with rally style driving, mostly on gravel. WARNING: at least 2GB of free disk space is needed! Pi-Apps automatically sets the game's settings for best performance. Feel free to experiment and find the best settings for you. Stunt Rally features a rich variety of 172 tracks in 34 sceneries also on other planets. Track difficulty ranges from short and easy, to very difficult stunt tracks including jumps, skewed loops, pipes winding in 3D, obstacles, or all of the above. Vehicle options: 20 cars, 1 motorbike, 3 hovering spaceships and 1 bouncing sphere. The latter provide a fast and easier gameplay on flat tracks. Game modes include: Single Race, Tutorials, Championships, Challenges, Multiplayer and Split Screen. Also Replays and Ghost drive are present. The Track Editor allows creating and modifying tracks. It uses a 3D spline generated road. To run: Menu -> Games -> Stunt Rally To run in terminal: stuntrally To run track editor: Menu -> Games -> Stunt Rally Track Editor To run in terminal: sr-editor","title":" Stunt Rally"},{"location":"apps-list/#unciv","text":"https://github.com/yairm210/Unciv - Added by Md. Touhidur Rahman Github: https://github.com/touhidurrr Website: https://touhidur.xyz Temurin Installation Script by theofficialgman Github: https://github.com/theofficialgman Enhanced Descriptions and Script Reviews by cycool29 Github: https://github.com/cycool29 Tested by Botspot Github: https://github.com/Botspot ARM32/ARM64 An open-source, mod-friendly Android+Desktop remake of Civ V A reimplementation of the most famous civilization-building game ever\u2014fast, small, no ads, free forever! Build your civilization, research technologies, expand your cities and defeat your foes! To run: Menu -> Games -> Unciv","title":" Unciv"},{"location":"apps-list/#internet","text":"","title":"Internet"},{"location":"apps-list/#angry-ip-scanner","text":"https://angryip.org - Added to pi-apps by Itai-Nelken. Big thanks to chunky-milk for finding that this app works on the rpi. https://github.com/chunky-milk/pi-bashscripts-files/tree/main/angry-ip-scanner ARM32/ARM64 Scans local networks as well as Internet IP Range, Random or file in any format. Exports results into many formats, Extensible with many data fetchers, Provides command-line interface, Free and open-source.","title":" Angry IP scanner"},{"location":"apps-list/#anydesk","text":"https://anydesk.com/en/downloads/raspberry-pi - @fabianmendes just brought it to the pi-apps. ARM32 ONLY AnyDesk is the ultimate remote desktop solution for editing and maintaining a desktop or server from a remote location using Linux on Raspberry Pi. Enjoy smooth and seamless remote operation of external computer systems. AnyDesk is free for private use and offers flexible license models for organizations. HOW TO RUN: JUST CLICK AND RUN.","title":" AnyDesk"},{"location":"apps-list/#caprine","text":"https://sindresorhus.com/caprine/ ARM32/ARM64 Caprine is an unofficial and privacy focused Facebook Messenger app with many useful features. Built with Electron, Caprine features a Dark mode, keyboard shortcuts, ability to toggle last seen/typing indicators, work chat support, code blocks, custom text size, and an interface that adapts to resizing windows. Caprine is a third-party app and is not affiliated with Facebook.","title":" Caprine"},{"location":"apps-list/#cloudbuddy","text":"https://github.com/Botspot/cloudbuddy - Botspot made, Botspot added. ARM32/ARM64 CloudBuddy is the ultimate wizard for cloud storage. Google Drive, Onedrive, Dropbox, and many more. Botspot made this gui frontend for the popular rclone tool to connect to your cloud drives, download from them, upload to them, mount them to your file manager, and more. In addition, CloudBuddy features an interactive file browser to easily generate shareable links and to perform various server-side operations. To run: Menu -> Internet -> CloudBuddy To run in terminal: ~/cloudbuddy/main.sh","title":" CloudBuddy"},{"location":"apps-list/#deluge","text":"https://www.deluge-torrent.org - Botspot Package app Lightweight BitTorrent client Use this to download torrent files from the Internet. For example, you can download a Torrent version of Raspberry Pi OS. To run: Menu -> Internet -> Deluge To run in a terminal: deluge-gtk Also see the Transmission app. Note: Torrents can contain illegal material, like pirated movies or cracked games. You use Deluge at your own risk.","title":" Deluge"},{"location":"apps-list/#deskreen","text":"https://deskreen.com/ - Thanks to pavlobu and all contibuters for developing Deskreen. Thanks to Crilum on GitHub for making the scripts. Thanks to ryanfortner on GitHub for having and hosting the debs! ARM32/ARM64 Share your desktop to your browser, and turn any device into a second screen! How to run: Menu -> Programming -> Deskreen or run from your Terminal: deskreen","title":" Deskreen"},{"location":"apps-list/#discord","text":"https://github.com/SpacingBat3/WebCord/ - Discord app by SpacingBat3 ARM32/ARM64 Fast Discord client for ARM that mimics the official Discord client. To run: Menu -> Internet -> WebCord. To run in a terminal: webcord The app runs independent to chromium and can be hidden to the system tray unlike other solutions out there. Made by SpacingBat3 on Github with care :)","title":" Discord"},{"location":"apps-list/#email-checker","text":"https://github.com/Botspot/raspi-email-checker ARM32/ARM64 Continuously checks for new emails and display a notification if there are any. When you click install, a window will appear for you to enter the email account's information and the time interval to check. If you want to change the settings later, just click the Install button again. Originally adapted from: https://learn.adafruit.com/raspberry-pi-e-mail-notifier-using-leds/python-script","title":" Email Checker"},{"location":"apps-list/#filezilla","text":"https://filezilla-project.org/ - Botspot Package app Download and upload files via FTP, FTPS, and HTTP This all allows you to connect to file-sharing servers on your home network or on the world wide web. To run: Menu -> Internet -> Filezilla To run in terminal: filezilla Note: For more cloud-storage, see the CloudBuddy app.","title":" Filezilla"},{"location":"apps-list/#lokinet","text":"https://wiki.oxen.io/wiki/Main_Page - This application is a product of ongoing research and various tool development of the Oxen Privacy Tech Foundation. https://optf.ngo/ ARM32/ARM64 Lokinet is a privacy focused network anyone can access using the latest in decentralized onion routing technology. Lokinet requires no internet IP Address but instead provides it's own network addresses which can be either ephemeral, persistent or personalized depending on the users desired application. Information is onion routed through a globally distributed network of over one thousand nodes. Hosting on Lokinet is quite easy and allows users to instantly create static addresses that can be privately accessed remotely over the internet for hosting their own online content. Using a Lokinet \"SNApp\" alleviates many of the challenges associated with hosting when it comes to configuring ports on a network. WIth SNApps there are no ports to forward. SNApps can be easily hosted on as little as an SBC inside a network and privately accessible anywhere in the world. SNApps also can hosted on a VPN using webservers such as Nginx, Apache, python etc. thereby allowing private anonymized global access your own personal content or sharing content privately among other users of the network. Web based applications such as IRC, Mumble, PeerTube, Pleroma, forums, streaming content etc. are all supportable through the network. The location and origin of the server is hidden and users anonymized while additionally the server can be secured in traditional ways. One can also register custom domains if they so choose to but this is not required to immediately generate a static address. Users wishing to access the regular internet anonymously need not pay for access to use Lokinet but may chose to subscribe to an exit provider should they wish to enhance anonymous access the internet through such a provider. Additionally the network generally has free exit nodes available offered through individuals providing voluntary support to the network. Currently the Oxen Privacy Tech Foundation offers free Lokinet exit node access at address \"exit.loki\". A wiki for Lokinet is located at https://wiki.oxen.io/wiki/Main_Page","title":" Lokinet"},{"location":"apps-list/#microsoft-teams","text":"https://github.com/IsmaelMartinez/teams-for-linux - @IsmaelMartinez on GitHub for the creation of the app. ARM32/ARM64 Microsoft Teams is a proprietary business communication platform developed by Microsoft, as part of the Microsoft 365 family of products. Teams primarily competes with the similar service Slack, offering workspace chat and videoconferencing, file storage, and application integration. To run: Menu -> Internet -> Teams Build with nativefier.","title":" Microsoft Teams"},{"location":"apps-list/#persepolis-download-manager","text":"https://persepolisdm.github.io/ ARM32/ARM64 Persepolis is a Download Manager and a GUI For aria2. It's written in Python. Persepolis is a Sample of Free and open source software. It's developed For GNU/Linux Distributions, BSDs, macOS and Microsoft Windows.","title":" Persepolis Download Manager"},{"location":"apps-list/#speedtest-cli","text":"https://www.speedtest.net/ ARM32/ARM64 Test your internet speed from a terminal! Are you familiar with speedtest.net? This tool is created by the same team. This version is much newer than the speedtest-cli package available in the repositories. To run: Menu -> Internet -> Run Speedtest To run in a terminal: speedtest","title":" SpeedTest-CLI"},{"location":"apps-list/#teamviewer-host","text":"https://github.com/Benmac83/Teamviewer-installer-for-pi - Credits go to @Benmac83 on the Botspot discord server ARM32 ONLY Remote desktop server software. To run: Menu -> Internet -> TeamViewer Host To run in terminal: teamviewer If you get an error running it from command line follow the instructions it gives you. They're very simple to follow.","title":" TeamViewer Host"},{"location":"apps-list/#telegram","text":"https://github.com/telegramdesktop/tdesktop ARM32/ARM64 Telegram is a free and open source, cross-platform, cloud-based instant messaging software. This service also provides end-to-end encrypted video calling, VoIP, file sharing and several other features. To run: Menu -> Internet -> Telegram Desktop To run from terminal: telegram-desktop","title":" Telegram"},{"location":"apps-list/#thunderbird","text":"https://www.thunderbird.net/features - Botspot Package app Email client with many features like a tabbed interface, smart spam filter, address book, search and filter tools, encryption, and numerous add-ons. To run: Menu -> Internet -> Thunderbird To run in a terminal: thunderbird","title":" Thunderbird"},{"location":"apps-list/#transmission","text":"https://transmissionbt.com - Botspot Package app Lightweight BitTorrent client Use this to download torrent files from the Internet. For example, you can download a Torrent version of Raspberry Pi OS. To run: Menu -> Internet -> Transmission Also see the Deluge app. Note: Torrents can contain illegal material, like pirated movies or cracked games. You use Transmission at your own risk.","title":" Transmission"},{"location":"apps-list/#web-apps","text":"https://itsfoss.com/web-app-manager-linux-mint/ - Phoenixbyrd for making it install successfully Botspot made the app. ARM32 ONLY Run websites as if they were apps. This is Linux Mint's official Web Apps program. Using it, you can run any website as a standalone app. If there are multiple browsers installed on the system, Web Apps will let you choose which one to use. It also lets you select an icon, menu category, and text label. When finished, a new button will appear in the main menu. To run: Menu -> Internet -> Web Apps To run in a terminal: webapp-manager","title":" Web Apps"},{"location":"apps-list/#wechat","text":"https://www.wechat.com/en/ - Install script written by RaspberryPiNews on YT With help from chills340 on Discord Script edits made by Botspot. Botspot was unable to login and test everything though. ARM32 ONLY WeChat is a Chinese multi-purpose instant messaging, social media and mobile payment app developed by Tencent. It was first released in 2011, it became the world's largest standalone mobile app in 2018, with over 1 billion monthly active users. WeChat provides text messaging, hold-to-talk voice messaging, broadcast (one-to-many) messaging, video conferencing, video games, sharing of photographs and videos and location sharing. WeChat Desktop App: - Run with box86 and wine - Smooth performance - Everything from gifs to emojis to images all work To run: Menu -> Internet -> WeChat","title":" Wechat"},{"location":"apps-list/#whatsapp","text":"no website - Apps compiled using Nativefier and scripts written by Itai-Nelken Nativefier made by jiahaog. Thanks to Botspot for help with debugging the menu shortcut and for creating pi-apps! ARM32/ARM64 Nativefier Whatsapp Web webapp A simple Whatsapp Web chromium webapp wrapped in electron with nativefier. it has a tray icon, so it doesn't take space on the taskbar, but keeps running in the background. To run: menu>internet>Whatsapp Web","title":" WhatsApp"},{"location":"apps-list/#xtreme-download-manager","text":"https://xtremedownloadmanager.com ARM32/ARM64 Xtreme Download Manager is a powerful tool to increase download speed up-to 500%, save and convert streaming videos from thousands of websites, resume broken/dead downloads and schedule downloads. XDM seamlessly integrates with Google Chrome, Mozilla Firefox Quantum, Opera, Vivaldi and many popular browsers, to take over downloads and saving streaming videos from web. XDM has built in video converter which lets you convert downloaded videos to popular MP4 and MP3 formats. Support for HTTP, HTTPS, FTP, DASH, HLS, HDS protocols, firewalls, proxy servers, PAC scripts, file redirects, cookies, authorization, download queue, scheduler and many more feature makes XDM a very useful tool","title":" Xtreme Download Manager"},{"location":"apps-list/#zoom","text":"https://github.com/Botspot/pi-apps/issues/188 ARM32/ARM64 Zoom video calls on the Raspberry Pi. This is the full desktop app, so you can do virtual backgrounds and Gallery View! This works by running the 32-bit x86 Zoom Linux app inside the box86 emulator. Performance is good enough on the Pi4. Turning off HD video in Zoom's settings is recommended.","title":" Zoom"},{"location":"apps-list/#zoom-pwa","text":"https://github.com/Botspot/zoom-pwa - Botspot ARM32/ARM64 Web-app for Zoom This is basically a web browser running Zoom's new Progressive Web App. Performance is better in some ways and worse in others. This app should be considered a backup option, only used if the regular Zoom app doesn't work at all. Both versions can be installed at the same time and will not interfere with each another. Note: this app requires you to have chromium-browser, chromium, or google-chrome installed. Let us know if your Chromium-based browser is not detected by the script. To run: Menu -> Internet -> Zoom PWA To run in a terminal: cat ~/.local/share/applications/chrome-gbmplfifepjenigdepeahbecfkcalfhg-Zoom-PWA.desktop | grep Exec | sed 's/Exec=//g' | bash","title":" Zoom PWA"},{"location":"apps-list/#internetbrowsers","text":"","title":"Internet/Browsers"},{"location":"apps-list/#browsh","text":"https://www.brow.sh/ ARM32/ARM64 The modern text-based terminal browser. Browsh is a modern text-based browser for the terminal. It renders anything that a modern browser can; HTML5, CSS3, JS, video and even WebGL. Its main purpose is to be run on a remote server and accessed via SSH/Mosh or the in-browser HTML service in order to significantly reduce bandwidth and thus both increase browsing speeds and decrease bandwidth costs. To run: Menu -> Internet -> Browsh To run in a terminal: browsh NOTE: This will also install firefox-esr","title":" Browsh"},{"location":"apps-list/#chromium","text":"Botspot Package app Open-source version of Google Chrome. If you are using Raspberry Pi OS, this browser has been optimized by the Raspberry Pi Foundation to include hardware acceleration and other various performance improvements. To play Netflix, Spotify, or other protected multimedia streams, see the Chromium Widevine app. To install an older version of Chromium, see the Downgrade Chromium app. Chromium supports numerous flags to enable extra features. You can add these flags either manually (by running chromium-browser in a terminal), or by adding the flag to a file in the /etc/chromium/customizations folder. Here's how that works: Inside the /etc/chromium/customizations folder there will be one or more files. On most systems there will already be a 00-rpi-vars file there. You can add flags to it, or create a new file. In all cases, be sure it starts with: CHROMIUM_FLAGS=\"${CHROMIUM_FLAGS} And be sure it ends with this character: \" Now that you know how to add flags to Chromium, here are some useful ones: - Enable Google Chrome Sync: --oauth2-client-id=77185425430.apps.googleusercontent.com --oauth2-client-secret=OTJgUOQcT7lO7GsGZq2G4IlT This flag is discussed in the Raspberry Pi Forums: https://forums.raspberrypi.com/viewtopic.php?t=314477 - Enable dark mode: --force-dark-mode If you want more themes, go visit the Chrome Web Store: https://chrome.google.com/webstore/category/themes - Change the scale of the browser window: --force-device-scale-factor=1.3 The default is 1 - smaller values will shrink the interface, while larger values will grow the interface. - More chromium flags can be found on this website: https://peter.sh/experiments/chromium-command-line-switches","title":" Chromium"},{"location":"apps-list/#downgrade-chromium","text":"https://www.raspberrypi.org/forums/viewtopic.php?f=63&t=308303 ARM32 ONLY Change Chromium versions easily. Chromium 65, 72, 74, 78, 84, 86, 88, 92, and 95. Uninstall the app to go back to the latest Chromium version available. Beware that downgrading Chromium versions can mess up your config folder. To be safe, this app makes a backup of Chromium's config folder. When uninstalling, you will have the opportunity to restore the backup config folder. All deb files are downloaded from https://archive.raspberrypi.org/debian/pool/main/c/chromium-browser","title":" Downgrade Chromium"},{"location":"apps-list/#falkon","text":"https://falkon.org ARM32/ARM64 Falkon is a KDE web browser using QtWebEngine rendering engine, previously known as QupZilla. It aims to be a lightweight web browser available through all major platforms. This project has been originally started only for educational purposes. But from its start, Falkon has grown into a feature-rich browser. Falkon has all standard functions you expect from a web browser. It includes bookmarks, history (both also in sidebar) and tabs. Above that, it has by default enabled blocking ads with a built-in AdBlock plugin. To run: Menu -> Internet -> Falkon","title":" Falkon"},{"location":"apps-list/#firefox-rapid-release","text":"Scripts made by chunky-milk Added to Pi-Apps by Tejas Singh YT Original Web-Browser made by Mozilla Foundation. ARM32/ARM64 Latest stable Mozilla Firefox version available. (Downloaded from Ubuntu Repo) Mozilla Firefox, is a free and open-source web browser developed by the Mozilla Foundation. To run: Menu -> Internet -> Firefox Web Browser To run in terminal: firefox","title":" Firefox Rapid Release"},{"location":"apps-list/#min","text":"https://minbrowser.org/ - @ryanfortner (GitHub) ARM32/ARM64 A fast, minimal browser that protects your privacy. To run: Menu -> Internet -> Min To run in terminal: min","title":" Min"},{"location":"apps-list/#pale-moon","text":"https://www.palemoon.org/ - Botspot ARM32/ARM64 A distant fork of Firefox, this is a lightweight and customizable web browser. Pale Moon offers you a browsing experience in a browser completely built from its own, independently developed source that has been forked off from Mozilla's code a number of years ago, with carefully selected features and optimizations to improve the browser's stability and user experience, while offering full customization and a growing collection of extensions and themes to make the browser truly your own. To run: Menu -> Internet -> Pale Moon To run in terminal: palemoon","title":" Pale Moon"},{"location":"apps-list/#puffin","text":"https://www.puffin.com/raspberry-pi/ - Botspot added this app to Pi-Apps. ARM32 ONLY Speeds up web browsing thanks to cloud servers. This web browser uses cloud servers to load websites for you, instead of making your Pi do it all. Result: a claimed 1600% browsing speed increase. To run: Menu -> Internet -> Puffin Internet Terminal (Demo) To run in a terminal: puffin-internet-terminal-demo","title":" Puffin"},{"location":"apps-list/#quartz","text":"https://github.com/ksharindam/quartz-browser-qt5 ARM32/ARM64 A useful fast Web Browser for Windows and Linux written in pyqt5 webkit. This browser is aimed at ease of use, faster page loading, very short startup time. This has minimal settings to avoid confusion.Yet it has most useful settings, such as load images on/off, javascript on/off, change font. To save pages to read later, print feature can be used to save as pdf. And it can also export the whole page as png image.","title":" Quartz"},{"location":"apps-list/#tor","text":"https://sourceforge.net/projects/tor-browser-ports/files/ ARM32/ARM64 The Tor Browser is a web broswer that anonymizes your web traffic using the Tor network, making it easy to protect your identity online.","title":" Tor"},{"location":"apps-list/#vivaldi","text":"https://vivaldi.com - Big thanks to chunky-milk for app idea and install script: https://github.com/chunky-milk/pi-bashscripts-files/tree/main/vivaldi Icon, description, and everything else required by pi-apps by Itai-Nelken ARM32/ARM64 Fast, private browser with unique features. Official Vivaldi browser for ARM Linux.","title":" Vivaldi"},{"location":"apps-list/#multimedia","text":"","title":"Multimedia"},{"location":"apps-list/#audacious","text":"https://audacious-media-player.org/ - Botspot Package app Lightweight but flexible audio player This is a playlist-style audio player, allowing you to drag folders and files to the list. It includes numerous audio effects, visualizations, and skins - even several Winamp ones! To run: Menu -> Sound & Video -> Audacious To run in a terminal: audacious","title":" Audacious"},{"location":"apps-list/#audacity","text":"https://www.audacityteam.org/ - Botspot Package app Easy-to-use audio editor with numerous features Supports live-recording, import/export, editing, effects, plugins, visualizations, keyboard shurtcuts, and much more. To run: Menu -> Sound & Video -> Audacity To run in a terminal: audacity Also see MuseScore2 and Sonic-Pi","title":" Audacity"},{"location":"apps-list/#bongo-cam","text":"https://github.com/kuroni/bongocat-osu - Install code made by Raspberry Pi News on Youtube Original app made by kuromi: https://github.com/kuroni/bongocat-osu ARM32 ONLY If you want to make a video but don't want to show your face, why not use this animated cat program? This app displays a cat. It can type on the keyboard or move the mouse. It mirrors your mouse movements. Default keyboard shortcuts: Z and X to tap on the keyboard, C to wear sunglasses, and V to wave. Go here for configuration options: https://github.com/kuroni/bongocat-osu/wiki/Settings NOTE: The app files are stored in ~/bongocam/","title":" Bongo Cam"},{"location":"apps-list/#chromium-widevine","text":"https://github.com/Botspot/chromium-v84-widevine ARM32 ONLY Widevine DRM support for any version of chromium-browser. This adds ChromeOS's Widevine video decoding library to Chromium, and creates a second menu button with a ChromeOS user-agent. All websites will think your Pi is a Chromebook! Unlike Ventz's Chromium Media Edition, or even the official libwidevinecdm0 package, this app is unique to support all versions of Chromium, before version 84 and after version 84. Feel free to downgrade your browser for better video performance! (Using the \"Downgrade Chromium\" app) To run: Menu -> Internet -> Chromium Widevine. To test DRM: https://bitmovin.com/demos/drm For normal browsing, it's advisable to use the standard Chromium launcher. This is known to work on these websites: \u2022 Netflix \u2022 Hulu \u2022 Amazon Prime \u2022 Disney+ \u2022 HBO \u2022 Spotify \u2022 Pandora \u2022 Hoopla \u2022 MUBI \u2022 BritBox \u2022 Bell Satellite TV","title":" Chromium Widevine"},{"location":"apps-list/#freetube","text":"https://freetubeapp.io/ - Installation Script and added to Pi-Apps by RPICoder ARM32/ARM64 Privacy-friendly YouTube player. Use YouTube without advertisements and prevent Google from tracking you with their cookies and JavaScript. FreeTube has an interface similar to YouTube, but is slower and more innefficient than YouTubuddy. Try both and see which one you prefer! Disabling the compositor improves playback performance.","title":" FreeTube"},{"location":"apps-list/#kodi","text":"https://kodi.tv/about - Botspot Package app Kodi is the ultimate entertainment center. Kodi excels at: - Movies - TV Shows - Music - Photos - Games - Skins and add-ons - Controllable with mouse, keyboard, web interface, smartphone apps, game controllers, and TV remotes To run: Menu -> Sound & Video -> Kodi To run in a terminal: kodi To make this run on startup, consider using the Autostar app.","title":" Kodi"},{"location":"apps-list/#musescore","text":"https://musescore.org - Botspot Package app Professional music notation software To run: Menu -> Sound & Video -> MuseScore 2 To run in terminal: mscore","title":" MuseScore"},{"location":"apps-list/#obs-studio","text":"https://obsproject.com/ - Install script made by Botspot and RPICoder :) ARM32/ARM64 Free and open source software for video recording and live streaming. To run: Menu -> Sound & Video -> OBS Studio To run in a terminal: obs","title":" OBS Studio"},{"location":"apps-list/#simplescreenrecorder","text":"https://www.maartenbaert.be/simplescreenrecorder/ - App Made by: MaartenBaert Suggestion from Kolpix Package app Feature-rich screen recorder for X11 and OpenGL Simple Screen Recorder is, despite its name, an actually feature-rich screen recorder. The name reflects the fact that it is simple to use unlike many other free screen recording applications available. It can be easily configured to start recording from an intuitive wizard-like interface. It can record the entire screen or part of it directly. The recording can be paused and resumed at any time. Many different file formats and codecs are supported. To perform an X11 recording, all it takes is selecting an area on the root window with the mouse, choosing an output file and pressing record, either by using the mouse or using a hotkey. It has a Qt-based graphical user interface. Its complexity becomes apparent in its powerful features. It allows one to record X11 screen areas and fullscreen OpenGL applications including sound supporting both ALSA, PulseAudio, JACK and OSS. It uses libavformat to encode the recorded material into a variety of video formats. Scaling the recorded video is possible as well as configuring the encoding quality for the codec chosen directly from the user interface.","title":" SimpleScreenRecorder"},{"location":"apps-list/#sonic-pi","text":"https://sonic-pi.net/#rp ARM32 ONLY Write code to make music. Latest version of Sonic Pi.","title":" Sonic Pi"},{"location":"apps-list/#wacup-new-winamp","text":"https://getwacup.com/ - Botspot for the scripts ralf1307 (github) issue #192 for the suggestion. ARM32 ONLY Cross-platform audio player - emulated Windows app","title":" WACUP (new WinAmp)"},{"location":"apps-list/#youtubuddy","text":"https://github.com/Botspot/youtubuddy - Botspot added this to Pi-Apps. ARM32/ARM64 Simple YouTube search engine, downloader and player. - No web browser required! Easily search for videos and play them with a few clicks. - Extremely lightweight - one bash script. - Perfect for downloading/playing batches of videos with a few clicks. - Supports searches, playlist URLs, and direct YouTube links. In addition, this supports URLs to many other video sites for easy downloading.","title":" YouTubuddy"},{"location":"apps-list/#tools","text":"","title":"Tools"},{"location":"apps-list/#alacritty-terminal","text":"https://github.com/alacritty/alacritty - Thanks to all contributors of the Alacritty project! Thanks to jmcerrejon on GitHub for making the compiling scripts! Thanks to ryanfortner on GitHub for hosting the deb, and cycool29 for making debs! Thanks to Crilum on GitHib for making the scripts! ARM32/ARM64 A fast, cross-platform, OpenGL terminal emulator Run from Menu: Menu -> System Tools -> Alacritty Run from Terminal: alacritty or with full path: /opt/alacritty/alacritty","title":" Alacritty Terminal"},{"location":"apps-list/#all-is-well","text":"https://github.com/spectrumgamer75/All-is-well ARM32/ARM64 ALL IS WELL is a bash script that allows users to easily update and upgrade their repositories and packages on linux. It will also fix any broken packages and dependencies. Forget about typing all update/upgrade commands manually, when ALL IS WELL!","title":" All Is Well"},{"location":"apps-list/#androidbuddy","text":"https://gitlab.com/gazlene/droidbuddy - Made by gazlene#8088 on Discord Added to pi-apps by Raspberry Pi News and Botspot ARM32/ARM64 A GUI for Android device recovery and maintenance. To run: Menu > Accessories > AndroidBuddy To run in a temrinal: python3 ~/droidbuddy/main.py Features: - APK Installation: Install an Android application package with ease. - Screen viewing and interaction: Control your device through an scrcpy window. - Recover files: Allows you to back up music, downloads, photos or all of your device's files. - AND MORE! Check out the website for more info.","title":" AndroidBuddy"},{"location":"apps-list/#antimicrox","text":"https://antimicrox.github.io/ - Thanks to: - All contributers for creating AntiMicroX. - ryanfortner for his information on how to build AntiMicroX. - Crilum on GitHub for writing the install/uninstall scripts. ARM32/ARM64 A graphical program used to map keyboard buttons and mouse controls to a gamepad. Useful for playing games with no gamepad support. Run from Menu: Menu -> Accesories -> AntiMicroX Run from Terminal: antimicrox","title":" AntiMicroX"},{"location":"apps-list/#autostar","text":"https://github.com/Botspot/autostar - Botspot made, Botspot added. ARM32/ARM64 Simple utility to make programs run on boot. The sky's the limit. People use this to: - Launch a website automatically, on boot. - Start a backup. - Launch your favorite apps on boot so they are ready to use sooner. - See what other apps have added autostart entries, and customize/disable them. To run: Menu -> Accessories -> AutoStar To run in terminal: ~/autostar/main.sh","title":" Autostar"},{"location":"apps-list/#balenaetcher","text":"https://www.raspberrypi.org/forums/viewtopic.php?f=62&t=255205&start=25#p1564958 - Etcher .deb compiled by Itai Nelken. ARM32/ARM64 Flash SD cards with a disk image. Many file types supported. To run: Menu -> Accessories -> BalenaEtcher To run in a terminal: /opt/balenaEtcher/balena-etcher-electron","title":" BalenaEtcher"},{"location":"apps-list/#bleachbit","text":"https://www.bleachbit.org/ ARM32/ARM64 BleachBit is a free and open-source disk space cleaner, privacy manager, and computer system optimizer. Not outdated like the APT repo's BleachBit. Like CCleaner on Windows, BleachBit frees space by deleting unimportant files and helps maintain your privacy by deleting sensitive data. And, just like CCleaner, there\u2019s more you can do with BleachBit than just clicking a single button. Better than free, BleachBit is open source. Comparison to APT version: - Nicer GUI look - With Abort function - With many function not included in APT version (Shred path from clipboard,make chaff and etc) - Clean deeper - Official dark theme support - Support showing debug messages","title":" BleachBit"},{"location":"apps-list/#box64","text":"https://github.com/ptitSeb/box64 - ptitseb for creating box64 debs made by @ryanfortner (GitHub) ARM64 ONLY Easily emulate x86_64 linux apps on Raspberry Pi. Box64 lets you run x86_64 Linux programs (such as games) on non-x86_64 Linux systems, like ARM (host system needs to be 64bit little-endian). Because Box64 uses the native versions of some \"system\" libraries, like libc, libm, SDL, and OpenGL, it's easy to integrate and use with most applications, and performance can be surprisingly high in many cases.","title":" Box64"},{"location":"apps-list/#box86","text":"https://github.com/ptitSeb/box86 - Itai-Nelken for his box86 debs and script creation ARM32 ONLY Easily emulate x86 linux apps on Raspberry Pi. Box86 lets you run x86 Linux programs (such as games) on non-x86 Linux, like ARM (host system needs to be 32bit little-endian). Because Box86 uses the native versions of some \"system\" libraries, like libc, libm, SDL and OpenGL, it's easy to integrate and use, and performance can be surprisingly high in some cases. Box86 now integrates a DynaRec (dynamic recompiler) for the ARM platform, providing a speed boost between 5 to 10 times faster than only using the interpreter.","title":" Box86"},{"location":"apps-list/#btop","text":"https://github.com/aristocratos/btop - Thanks to: - aristocratos and all contributers. - Crilum on GitHub for writing the scripts. ARM32/ARM64 Awesome terminal resource monitor and task manager, similar to htop. Run from Terminal: btop btop shows CPU, memory, network, and disk usage, along with a task manager. btop is also very user customizable, with different layouts and ways of displaying CPU, memory, network and disk usage. If you want to look at screenshots of btop, go to the GitHub README.","title":" btop++"},{"location":"apps-list/#clam-antivirus","text":"https://gitlab.com/dave_m/clamtk ARM32/ARM64 Open-source antivirus for your pi Run with the command \"clamscan\" or go to Menu > Utility > ClamTK. \u2219 Open source \u2219 Install it, set a schedule and forget it \u2219 Scans your entire filesystem \u2219 Moves suspicious files to quaratine \u2219 Has a GUI to control it","title":" Clam Antivirus"},{"location":"apps-list/#commanderpi","text":"https://github.com/Jack477/CommanderPi ARM32/ARM64 Easy RaspberryPi4 GUI system managment Using CommanderPi, you can change overclock settings, bootloader settings, switch kernels, and view performance diagnostics. To run: Menu -> Accessories -> CommanderPi To run in a terminal: /home/pi/CommanderPi/src/start.sh","title":" CommanderPi"},{"location":"apps-list/#disk-usage-analyzer","text":"https://wiki.gnome.org/Apps/DiskUsageAnalyzer - Botspot Package app Ever wonder where you put that big file, or why your SD card is full? Now you can, with a glance at a pie chart. To run: Menu -> System Tools -> Disk Usage Analyzer To run in a terminal: baobab","title":" Disk Usage Analyzer"},{"location":"apps-list/#ff-multi-converter","text":"https://sites.google.com/site/ffmulticonverter/ - Thanks to Crilum on GitHub for writing the scripts. Thanks to ilstad on GitHub and all Contributors for creating FF Multi Converter! ARM32/ARM64 FF Multi Converter is a simple graphical application for Linux which enables you to convert audio, video, image and document files. It uses FFmpeg for audio/video files, the ImageMagick software suite for image conversions and unoconv for document files. The goal of FF Multi Converter is to gather the most popular multimedia types in one application and provide conversion options for them easily through a user-friendly graphical interface. Run from Menu: Menu -> Accesories -> FF Multi Converter Run from Terminal: ffmulticonverter","title":" FF Multi Converter"},{"location":"apps-list/#flameshot","text":"https://flameshot.org/ - Flameshot.org for creating the tool + all github contributors CleanMachine1 for the install scripts and suggestion Itai-Nelken for finding the .deb files for installing Chunky-Milk for hosting the .deb file in their Github ARM32/ARM64 A simple tool to take screenshots of your screen or just parts of the screen. It is similar to Microsoft's Snipping Tool. To launch: Menu -> Graphics -> Flameshot To use: find the flameshot icon in your taskbar (system tray) and click it to open Flameshot. To run in a terminal: flameshot","title":" Flameshot"},{"location":"apps-list/#geekbench","text":"https://www.geekbench.com/ ARM32/ARM64 Geekbench 5 is a cross-platform benchmark that measures your system's performance with the press of a button. How will your mobile device or desktop computer perform when push comes to crunch? How will it compare to the newest devices on the market? Find out today with Geekbench 5. To run in terminal: geekbench","title":" Geekbench"},{"location":"apps-list/#github-cli","text":"https://cli.github.com/ - Added to pi-apps by Itai-Nelken ARM32/ARM64 gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code. to run (terminal only): gh","title":" Github-CLI"},{"location":"apps-list/#gparted","text":"https://gparted.org - Botspot Package app Graphically manage disk partitions With GParted you can resize, copy, and move partitions without data loss, enabling you to: - Grow or shrink your C: drive - Create space for new operating systems - Attempt data rescue from lost partitions To run: Menu -> System Tools -> GParted To run in a terminal: sudo gparted","title":" GParted"},{"location":"apps-list/#guake-terminal","text":"http://guake-project.org/ - Botspot ARM32/ARM64 Guake is a top-down terminal, inspirated by the famous terminal used in Quake. You can show and hide your terminal with a single key stroke, execute a command, and then go back to your previous task without breaking your workflow. To run: Press F12. (Guake runs automatically on startup) To run manually: Menu -> System Tools -> Guake Terminal To run in a terminal: guake","title":" Guake Terminal"},{"location":"apps-list/#https-file-server","text":"http://www.rejetto.com/hfs/?f=intro ARM32 ONLY Simple file-sharing webserver. Other computers on your local network can connect to your computer from the web browser and download files you share. Or, you can enable port forwarding on your router so that anyone on the Internet can download your files. This app uses Wine to run a windows exe file. To launch: Menu -> Applications -> HTTPS File Server","title":" Https File Server"},{"location":"apps-list/#imager","text":"https://www.raspberrypi.org/blog/raspberry-pi-imager-imaging-utility - Botspot Package app Raspberry Pi's official SD card imaging utility. This includes many features and customizations you can make to the image before flashing, and is overall very reliable. To run: Menu -> Accessories -> Imager To run in terminal: rpi-imager","title":" Imager"},{"location":"apps-list/#keepassx","text":"https://github.com/keepassxreboot/keepassxc - @ryanfortner (GitHub) for the scripts @raspbian-addons maintainers for the deb ARM32/ARM64 KeePassXC is a modern, secure, and open-source password manager that stores and manages sensitive information. Run via the Main Menu > Accessories > KeePassXC","title":" KeePassX"},{"location":"apps-list/#mission-planner","text":"https://ardupilot.org/planner/ - Botspot made this app. ARM32/ARM64 Software used to control autonomous vehicles. Mission Planner is a free, open-source ground station for communicating with autonomous aircraft, vehicles, or boats running Ardupilot firmware. It's used to monitor such vehicles, view logs, and create waypoint missions.","title":" Mission Planner"},{"location":"apps-list/#nautilus","text":"https://wiki.gnome.org/Apps/Files - Botspot Package app Feature-rich file manager for the GNOME desktop To run: Menu -> Accessories -> Nautilus To run in terminal: nautilus","title":" Nautilus"},{"location":"apps-list/#nodejs","text":"https://nodesource.com/ - Script by ilobilo Script improved by Itai-Nelken ARM32/ARM64 JavaScript code outside a web browser. Node.js is used for all npm packages and is the foundation of Electron. As usual, this app will keep it updated.","title":" Node.js"},{"location":"apps-list/#pi-apps-terminal-plugin-bash","text":"Created and added to pi-apps by Itai-Nelken ARM32/ARM64 Pi-apps terminal is a script that lets you use pi-apps from the terminal, its written in bash. It has all the commands you will ever need: 'install' - install a app available in pi-apps. 'remove' - uninstall a app installed by pi-apps (uninstall also works). 'multi-install' - install multiple apps. 'multi-remove' - uninstall multiple apps (multi-uninstall also works). 'list-all' - list all the apps in pi-apps (note that this will also list apps that are not available for your OS). 'list-installed' - list all the apps installed by pi-apps. 'list-uninstalled' - list all the uninstalled apps. 'list-corrupted' - list all the corrupted apps. 'search' - usage: search \"search-term\". search a app available in pi-apps (note that this will show results from the description of the 'apps as well as their name). 'website' - usage: website \"app-name\". print the website of a app available in pi-apps. 'update' - update all pi-apps components. 'update-apps' - update all pi-apps apps only. 'gui' - launch pi-apps regularly. and it makes life easier by eliminating the use of quotes for apps with a space in their name (unless you are using 'multi-install' or 'multi-uninstall').","title":" Pi-Apps Terminal Plugin (bash)"},{"location":"apps-list/#pi-apps-terminal-plugin-python","text":"https://github.com/techcoder20/PiAppsTerminalAdvanced - App made by and added to pi-apps by RPICoder ARM32 ONLY This is a terminal version of pi apps but with more features. Usage pi-apps [argument] Available Arguments: \"list-all\" Prints the list of available apps that are installable \"list-installed\" Prints all installed apps \"list-uninstalled\" Prints all uninstalled apps \"install [appname]\" Install any app available in pi-apps \"uninstall [appname]\" Uninstall any app available in pi-apps \"search [appname]\" Search for a app in pi apps \"website [appname]\" Prints website for app \"update\" Update pi-apps \"gui\" Launches gui for pi-apps Run \"pi-apps help\" to get this information","title":" Pi-Apps Terminal Plugin (python)"},{"location":"apps-list/#pigro","text":"https://github.com/actionschnitzel/PiGro-Aid- ARM32/ARM64 PiGro is a program designed to make all Debian-based distributions easier to use on the Pi. The most common terminal commands can be executed with one click.","title":" PiGro"},{"location":"apps-list/#pikiss","text":"https://github.com/jmcerrejon/PiKISS ARM32 ONLY A bunch of scripts with a menu to make your life easier. To run: Menu -> System Tools -> PiKiss To run in a terminal: ~/piKiss/piKiss.sh \u2219 Easy system configuration \u2219 Ability to install your favourite games like Half Life \u2219 Emulators galore! \u2219 Install apps like OBS and Cool-Retro-Term! \u2219 AND MUCH MORE!","title":" piKiss"},{"location":"apps-list/#pi-power-tools","text":"https://github.com/Botspot/Pi-Power-Tools ARM32/ARM64 Easily edit RaspiOS image files with a suite of useful tools. All features: Advanced Mount, Shrink, Expand, Flash, Boot in a VM, Download, Mount (View), Edit partitions, and Repair. To run: Menu -> Accessories -> Pi Power Tools To run in a terminal: ~/Pi-Power-Tools/home","title":" Pi Power Tools"},{"location":"apps-list/#pisafe","text":"https://github.com/RichardMidnight/pi-safe ARM32/ARM64 Create compressed image files. Flash SD cards from a disk image. Many file types supported. To run: Menu -> Accessories -> PiSafe To run in a terminal: pisafe","title":" PiSafe"},{"location":"apps-list/#qemu","text":"https://www.qemu.org/ - Added to Pi-Apps by Itai-Nelken debs compiled and packaged using QEMU2DEB (tool by Itai-Nelken) by ryanfortner. ARM32/ARM64 QEMU is a generic and open source machine emulator and virtualizer. Latest version of QEMU, Not outdated like the repository's QEMU. If you ever had trouble using the repository's QEMU, this version will work way better. (for example the MacOS 9 dock doesn't appear using the repository's QEMU).","title":" QEMU"},{"location":"apps-list/#raspi2png","text":"https://github.com/AndrewFromMelbourne/raspi2png ARM32/ARM64 Takes a screenshot of the framebuffer. Useful for overlay applications, like Minecraft or VLC, as this will capture them properly. Run in a terminal: raspi2png The resulting image will be saved to /home/pi/snapshot.png","title":" Raspi2png"},{"location":"apps-list/#scrcpy","text":"https://github.com/Genymobile/scrcpy ARM32/ARM64 Screen mirror over USB or wireless ADB","title":" Scrcpy"},{"location":"apps-list/#screenshot","text":"https://apps.gnome.org/app/org.gnome.Screenshot - Botspot Package app Simple interface for capturing screenshots, similar to the Windows Snipping Tool. To run: Menu -> Accessories -> Screenshot To run in terminal: gnome-screenshot","title":" Screenshot"},{"location":"apps-list/#snapdrop","text":"https://github.com/RobinLinus/snapdrop - Added by @ryanfortner (Github) ARM32/ARM64 Share files with nearby devices on the local network. Inspired by Apple's Airdrop. To run: Menu -> Internet -> Snapdrop To use: Open a web browser on the other computer/smartphone and go to snapdrop.net Now drag and drop files to the website, and the other device will see the files and download them.","title":" Snapdrop"},{"location":"apps-list/#snap-store","text":"https://snapcraft.io/store - Installation script and made by RPICoder ARM32/ARM64 Snaps are app packages for desktop, cloud and IoT that are easy to install, secure, cross\u2010platform and dependency\u2010free. Snaps are discoverable and installable from the Snap Store, the app store for Linux with an audience of millions.","title":" Snap Store"},{"location":"apps-list/#synaptic","text":"https://www.lifewire.com/guide-to-synaptic-package-manager-220570y - Botspot Package app Advanced APT-package-management tool To run: Menu -> Preferences -> Synaptic Package Manager To run in terminal: sudo synaptic","title":" Synaptic"},{"location":"apps-list/#sysmontask","text":"https://github.com/KrispyCamel4u/SysMonTask - @KrispyCamel4u (GitHub) for the program @ryanfortner (GitHub) for the scripts ARM32/ARM64 Linux system monitor similar to the Windows task manager, written in Python. Run via the Main Menu > System Tools > SysMonTask.","title":" SysMonTask"},{"location":"apps-list/#sysmon","text":"https://github.com/t0xic0der/sysmon - @t0xic0der on GitHub for the creation of the app @ryanfortner on GitHub for the scripts ARM32/ARM64 Monitor your Raspberry Pi using a web browser on another computer. This is a background service that hosts a website at <your Pi's IP address>:6969. Using any computer on your local network, you can go to that website and view many useful statistics. (And some useless ones too) For testing purposes, you can look at the website from the Pi itself by launching Chromium browser and going to http://localhost:6969 As mentioned earlier, the website is only visible to computers in the local network.","title":" Sysmon"},{"location":"apps-list/#temps","text":"https://github.com/musicpro/temps - Thanks to Crilum on GitHub for making the scripts. Thanks to jackd248 on GitHub for the original temps. Thanks to promusic on GitHub for forking and continuing development on this awesome app! ARM32/ARM64 Temps is a modern and minimal menubar application based on Electron with actual weather information and forecast. Run from: Menu -> Accessories -> Temps or from Terminal: temps","title":" Temps"},{"location":"apps-list/#timeshift","text":"https://github.com/teejee2008/timeshift - app created by: teejee2008 https://github.com/teejee2008/ Added to pi-apps by: Itai-Nelken https://github.com/Itai-Nelken/ https://bit.ly/raspberry-pi-stuff-YT ARM32/ARM64 System restore tool for Linux that provides functionality similar to the System Restore feature in Windows and the Time Machine tool in Mac OS. System restore tool for Linux. Creates filesystem snapshots using rsync+hardlinks, or BTRFS snapshots. Supports scheduled snapshots, multiple backup levels, and exclude filters. Snapshots can be restored while system is running or from Live CD/USB. to run from terminal: timeshift","title":" Timeshift"},{"location":"apps-list/#tldr","text":"https://github.com/dbrgn/tealdeer - Ported to pi-apps by Raspberry Pi News on youtube Made by the community at https://github.com/tldr-pages/tldr ARM32/ARM64 The tldr project is a collection of community-maintained help pages for command-line tools, that aims to be a simpler, more approachable complement to traditional man pages. Run it by typing \"tldr <command>\" into terminal. Maybe you are new to the command-line world? Or just a little rusty? Or perhaps you can't always remember the arguments to lsof, or tar? It also is more digestable than man pages which blasts pages of useless stuff at you every time you use it.","title":" tldr"},{"location":"apps-list/#update-buddy","text":"https://github.com/Botspot/update-buddy ARM32/ARM64 Automatically check for APT updates on boot. If anything can be upgraded, asks permission to upgrade. To run: should run automatically on startup. To run in a terminal: ~/update-buddy/onstartup.sh","title":" Update Buddy"},{"location":"apps-list/#usbimager","text":"https://bztsrc.gitlab.io/usbimager/ ARM32/ARM64 A very minimal GUI app that can write compressed disk images to USB drives. USBImager is a very useful and minimal app that works like etcher and Raspberry Pi imager but needs less resources, (it's less then 400kb). To run from terminal, type: usbimager.","title":" USBImager"},{"location":"apps-list/#veracrypt","text":"https://www.veracrypt.fr/en/Documentation.html - nielsbaloe on Github suggested this be added. Botspot added it. ARM32 ONLY Open source disk encryption software - Creates a virtual encrypted disk within a file and mounts it as a real disk. - Encrypts an entire partition or storage device such as USB flash drive or hard drive. - Encrypts a partition or drive where Windows is installed (pre-boot authentication). - Encryption is automatic, real-time(on-the-fly) and transparent. - Parallelization and pipelining allow data to be read and written as fast as if the drive was not encrypted. - Encryption can be hardware-accelerated on modern processors. - Provides plausible deniability, in case an adversary forces you to reveal the password: Hidden volume (steganography) and hidden operating system. - More information about the features of VeraCrypt may be found in the documentation.","title":" VeraCrypt"},{"location":"apps-list/#windows-flasher","text":"https://github.com/Botspot/wor-flasher - Botspot ARM32/ARM64 Install Windows 10 or Windows 11 on a Raspberry Pi SD card. This tool is a 100% legal way to use any Debian or Ubuntu Linux operating system to flash a RPi's SD card with the necessary files to run Windows 10 or 11. Usage is simple: - Choose an operating system version. (Windows 11, Windows 10, Custom version) - Choose what model Pi will be running Windows. (RPi4 or RPi3) - Choose a language. - Choose a storage drive to flash. - Click Flash. It's as simple as that. WoR-flasher takes care of the rest - downloading hundreds of files from Microsoft, generating a Windows image with them, importing the custom RPi drivers, enabling the WinPE environment, and much more. When finished, WoR-flasher will tell you exactly what to do next. To run: Menu -> Accessories -> WoR-Flasher To run the graphical interface in a terminal: ~/wor-flasher/install-wor-gui.sh To run the command-line interface in a terminal: ~/wor-flasher/install-wor.sh If you encounter problems, we recommend you run WoR-flasher in a terminal to catch any errors.","title":" Windows Flasher"},{"location":"apps-list/#wine-x86","text":"https://www.winehq.org/ - Script by Itai-Nelken and Botspot ARM32 ONLY Run x86 Windows apps with a box86-emulated version of x86 wine. To run: wine path/to/file.exe To configure wine: go to 'Wine configuration' in main menu or type in terminal: wine winecfg Not all Windows applications will work under Wine. It's a good idea to check online if your program can run, or if something can be tweaked to make it work. Note: the applications installed with wine will appear under the wine category in the main menu, and they will stay there even after uninstalling wine. Need support with running a game or app with wine and box86? Ask it on the Pi Labs Discord: https://discord.gg/JKNQXprqUd","title":" Wine (x86)"},{"location":"introduction/","text":"Pi-Apps is written in bash . This is a scripting language for Linux, with origins in the 80s. Bash is not a compiled language like C, it's an interpreted language, similar to Python and Windows .bat files. Bash serves a different purpose than a compiled language: orchestrating OS-level events and prioritizing programming-time over execution-time. It is system-dependent and architecture-dependent. You probably interact with bash without even realizing it! Nearly all Linux distributions today use a bash terminal . If you have ever opened a terminal, you have interacted with bash. Pi-Apps is comprised of bash scripts . These are text files that are filled with bash commands. To illustrate this, you can often open a bash script, copy the contents, and paste it into a bash terminal. And it will work exactly the same as if you executed the file! In fact, if Pi-Apps was reorganized into a single standalone bash script, you could copy and paste the entire thing into a terminal and have a working app store! If Pi-Apps is only bash scripts, how does it display a GUI ? (graphical user interface) Good question. When Pi-Apps was just a concept, I knew that bash was the obvious choice for installing apps. And that makes sense: if you normally install an application by running commands in a bash-terminal , it only makes sense to use a bash-script . Bash was the best choice for installing apps, but what about the GUI? Most GUIs are made in C, C++, Python or JavaScript with GTK, Qt, or Electron. These were workable options, but for long-term maintainability and convenience I wanted to only use one language for the whole thing . Someone suggested zenity - a simple dialog program meant for bash scripts. I tried it, but was soon frustrated by its limitations. Then I discovered yad - an improved version of zenity with many more options. Pi-Apps uses yad for everything.","title":"Introduction"},{"location":"folders/the-app-folder/","text":"It makes sense to start here. After all, what is an app store without apps? Basically, for every app, there is a folder . This folder is called an \" app-folder \". On a default pi-apps installation, all app-folders are located in /home/pi/pi-apps/apps . The folder's name is the app's name. The Arduino app is a folder located at apps/Arduino . There are a few files in each app-folder: - install - This is a bash script to install the app. - Naming the script \"install\" indicates that it is compatible with 32-bit and 64-bit CPU architectures. - install-32 - This is a bash script to install the app on 32-bit operating systems. - Naming the script \"install-32\" indicates that it is designed for the 32-bit CPU architecture only. - If no \"install-64\" script exists, then this app will only be displayed on 32-bit systems. - install-64 - This is a bash script to install the app on 64-bit operating systems. - Naming the script \"install-64\" indicates that it is designed for the 64-bit CPU architecture only. - If no \"install-32\" script exists, then this app will only be displayed on 64-bit systems. - uninstall - This is a bash script to uninstall the app. - icon-24.png and icon-64.png - These are the app's icons. - description - This is a text file to explain what the app is, how it works, and why anybody would want it. - The first line of this file is used as the tooltip (mouse hover-text) in the list of apps. - credits - This is a text file to give credit to the person who made the app. - website - This is a text file containing the website URL of a given project. - Usually it points to a website where users can learn more about the app.","title":"The app folder"},{"location":"folders/the-app-status-folder/","text":"Pi-Apps keeps track of each app's status: installed or uninstalled. (as well as a few other possible values) Each app's status is located in the data/status folder. For example, on a default Pi-Apps installation, the status file for arduino is located at: /home/pi/pi-apps/data/status/Arduino . Each file in this folder will contain one of these possible values: - installed - The app is currently installed. - uninstalled - The app is currently uninstalled. - corrupted - The app failed to install/uninstall. - disabled - The app is in a disabled state: it will not be installed under any circumstances. - This status is useful for TwisterOS where Box86 comes pre-installed. We don't want Pi-Apps installing Box86 under any circumstances, even if another app requires it to be installed. As mentioned earlier, Pi-Apps runs on bash scripts. Each script has a certain job to do, and together they make Pi-Apps work. See the scripts folder for how each individual script works.","title":"The app status folder"},{"location":"folders/the-main-pi-apps-folder/","text":"The Pi-Apps folder contains several main subfolders. These folders have special characteristics and are treated differently during updates. - The data folder and logs folder contain files that should never be updated . They contains settings, cached files, app-status files, log files, etc. - The apps folder contains apps. During an update it this folder is handled differently too. - Other folders like icons and etc are handled the same as individual files in the main pi-apps folder.","title":"The main pi apps folder"},{"location":"scripts/the-api-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/api . Purpose: This script is a collection of functions that do various things. Functions are small chunks of bash-code that can be run like a normal command. Usage: source ~/pi-apps/api You can now run any of the functions inside the api script as if they were real commands. Alternatively, the api script supports running a single function without being sourced: ~/pi-apps/api apt_lock_wait List of functions: Note: new functions are added often. If you don't see a function on this list but do see it in the api, please let us know. - error - display a custom message in red and exit with a return code of 1 . Usage: error \"The command 'sudo apt update' failed!\" This is often seen at the end of a command with the || operator: sudo apt update || error \"The command 'sudo apt update' failed!\" - warning - Display a custom message in yellow and prefix it with \"WARNING: \". - Useful for everything where something is wrong but it's not a fatal error. - This function outputs to stderr . - status - Display a custom message in light-blue. - Used by scripts to indicate current status, like \"Downloading...\", \"Extracting...\", and \"Please wait.\" - This function outputs to stderr . - Some scripts don't want the ending newline, so this function allows for flags to be passed to the echo command. Example usage: status -n \"Downloading... \" - status-green - Display a custom message in green. - Used by scripts to indicate the success of an action, like \"Installed FreeCAD successfully\", \"Update complete\", and \"All packages have been purged successfully.\" - This function outputs to stderr . - generate_logo - Displays the Pi-Apps logo in a terminal. - add_english - Ensures an English locale is installed so that log-diagnosing tools can function properly. - This was added in PR #1031 Apt/dpkg/package functions below. apt_lock_wait - waits until apt locks are released. package_info - List everything dpkg knows about the specified package. This retrieves a block of text from the /var/lib/dpkg/status file. package_installed - determine if the specified package is installed. Returns an exit code of 0 if the package is installed, otherwise it returns 1 . package_available - determine if the specified package is able to be installed with apt . This uses grep to search the /var/lib/apt/lists/ folder. Returns an exit code of 0 if the package was found, otherwise it returns 1 . package_dependencies - List the dependencies of a package This simply isolates a line from the output of the package_info function. This is much faster than doing an apt-cache search . less_apt - Reduce the output of an apt operation. Example usage: bash sudo apt update 2>&1 | less_apt apt_update - A wrapper function to run sudo apt update . This will wait for apt locks to be released, handle status information, and display helpful tips if packages are upgradable or autoremovable. Arguments to the function will be passed on to the apt command. Below are three functions that manage the Pi-Apps local APT repository . This is a special folder ( /tmp/pi-apps-local-packages ) used by the install_packages function to handle installing local deb files. Installing local packages from a repository improves dependency-handling, condenses the operation into one apt operation, and allows the packages to be specified in any order. repo_add - Add the specified deb file(s) to the local repository. This simply copies specified files to the /tmp/pi-apps-local-packages folder. repo_referesh - Index the local repository, create a Packages file, and a source.list . At this point, you can make apt use the repository by passing this flag to it: -o Dir::Etc::SourceList=/tmp/pi-apps-local-packages/source.list repo_rm - Removes the local repository. app_to_pkgname - Convert an app-name to an apt -compatible package name. This function generates the name to use for creating dummy apt packages. The naming scheme is: pi-apps-XXXXXXXX (each X can be any lowercase letter or number) View which dummy packages are installed now by running apt search pi-apps- in a terminal. install_packages - Used by apps to install packages. This function is replacing the pkg-install script. Example usage: install_packages package1 /path/to/package2.deb https://example.com/package3.deb package4-* || exit 1 First, each argument is analyzed. If it's a URL, the file is downloaded and added to the local repository. If it's a deb-file, it's added to the local repository. If it contains regex (regular expression, aka the * character), a list of packages is generated using the apt-cache search command. Next, the local repository is initialized. (if necessary) Now an apt_update takes place. It's time to configure and install an empty apt-package that \"depends on\" the packages we want to install. We refer to it as a \"dummy deb\". First the name of the dummy deb is determined, using the app_to_pkgname function. If the dummy deb is already installed, install_packages will inherit its dependencies and then purge the dummy deb. This means that the install-packages function can be used multiple times in an app's script because it's accumulative. The dummy deb is created, packaged, and finally installed. purge-packages - Used by apps to remove packages that they previously installed. This function accepts no arguments. It reads the $app variable, purges its associated dummy deb, and autoremoves any packages that are no longer necessary. get_icon_from_package - Given a package (or space-separated list of packages), this function will automatically find the program icon for it. This is useful for the createapp script to automatically find a suitable icon for package-apps you're trying to add. This uses dpkg-query to list all files each package installed. The list is filteres to only show .png files in /icons/ or /pixmaps/ folders. The list is sorted by filesize to find the picture with the most pixels. End of apt functions. App functions below. list_apps - List all apps that match a given criteria. (In a newline-separated format) list_apps local will list apps that exist locally. list_apps is the same as list_apps local . list_apps app will list all apps, both local and online. list_apps installed will list apps that are currently installed. list_apps corrupted will list apps that are currently corrupted. list_apps disabled will list apps that are currently disabled. list_apps uninstalled will list apps that are currently uninstalled. list_apps have_status will list apps that currently have a known status. (A clean Pi-Apps installation won't have any status files) list_apps missing_status will list apps that don't have status files. list_apps cpu_installable will list apps that have an installation script compatible with your operating system's CPU architecture. If \"app1\" only has an install-64 script but your system is 32-bit, then \"app1\" will be excluded from this list. Likewise, if \"app1\" only has an install-32 script but your system is 64-bit, then \"app1\" will be excluded from this list. list_apps package will list apps that don't have scripts but have a packages file. list_apps standard will list apps that do have scripts and don't have a packages file. list_apps hidden will list apps that are in the special \"hidden\" category. list_apps visible will list apps that are not in the special \"hidden\" category. list_apps online will list apps that exist in the update/pi-apps/apps folder. list_apps online_only will list apps that are only in the update/pi-apps/apps folder. list_apps local_only will list apps that are not in the update/pi-apps/apps folder. list_intersect - Takes two lists of apps and intersects them, meaning that only apps that are listed in both lists are returned. For example, this will show apps that are both cpu_installable and visible: list_apps cpu_installable | list_intersect \"$(list_apps visible)\" list_subtract - Takes two lists of apps and subtracts one from other, meaning that only apps listed in the first list and not in the second list, are returned. For example, this will show apps that are not compatible with your system's architecture: list_apps local | list_subtract \"$(list_apps cpu_installable)\" read_category_files - Generates a list of categories; data compiled from the data/category-overrides and etc/categories files, with added support for unlisted apps. app_categories - Format the categories file, then list all apps, as if they were inside folders, based on the categories file. Also lists all apps under special \"Installed\" and \"All Apps\" categories. bitly_link - Increase/decrease the \"number of users\" a certain app has. Botspot creates bitly links for every app: one link for installing it, and one link for uninstalling it. Bitly will track how many times each link has been clicked. Assuming the \"Enable Analytics\" setting was not turned off, this function will \"click\" one of those links. Botspot uses a script to upload bitly's statistics to the pi-apps-analytics repository. usercount - returns the number of users an app has, based on the current number in the pi-apps-analytics repository. To display the number of users for the Arduino app: usercount Arduino script_name - returns name of install script(s) for the specified app. Possible outputs: '', 'install', 'install-32', 'install-64', 'install-32 install-64' Usage: script_name Arduino script_name_cpu - Given an app, this returns the name of the app's installation script that would be run if you ran it. For example, if your operating system is 32-bit and the app has an install-32 script, this function would return \"install-32\". If your operating system is 64-bit and the app has an install-64 script, this function would return \"install-64\". If the app has an install script, this function would return \"install\". If none of the above, don't return anything. app_status - return the given app's current status. If the app's status file does not exist, this function returns 'uninstalled'. Otherwise, this function returns the contents of the app's status file. app_type - Determine if an app is a standard app or if it's a package . will_reinstall - Return an exit code of 0 if the specified app would be reinstalled during an update, otherwise return an exit code of 1 . If the app's existing installation script is not identical to the new version of the installation script, AND the app is currently installed, exit with a code of 0 , otherwise exit 1 . app_search - Search all apps for the specified search query. In each app-folder, this will search for matches in the following files: description credits website It hides incompatible and invisible apps before displaying the results. (list of app names, one per line) app_search_gui - A graphical front-end for the app_search function. This displays all results from app_search in a graphical list. One app should be selected from the list before clicking OK. If only one app is displayed in the list, no need to select it. The chosen app (if any) is returned. generate_app_icons - Resize a specified image and place the icons in the specified app-folder. This requires imagemagick to be installed. If it's missing, a dialog box will appear and ask permission to install it. Example usage: generate_app_icons /path/to/my-image.png my-app refresh_pkgapp_status - For the specified package-app, if dpkg thinks it's installed, then mark it as installed. refresh_all_pkgapp_status - For every package-app, if dpkg thinks it's installed, then mark it as installed. Logfile functions below. - get_logfile - Find the most recent logfile for the specified app. - log_diagnose - Search a specified logfile for phrases that indicate non-errors. - Many errors are not Pi-Apps's fault. Most are outside of Pi-Apps's control, but caused by user-interference, Internet problems, or apt configuration errors. - Errors are categorized into three types: system , internet , package , and unknown. - If a known phrase is identified, the $error_type variable is set to either system or internet or package . - If no phrases were identified, the $error_type variable will be set to unknown . Only when the error_type is \"unknown\" will Pi-Apps allow the user to send an error report. - Each detected error has an accompanying caption for the user to read. This caption explains what the problem is and how to fix it. - As multiple error messages might be identified, the error captions are stored in an array variable called $error_caption . Storing explanations in an array allows multiple explanations to be displayed to the user. - Before exiting, this function returns the collected information. The first line is the value of $error_type , while subsequent lines are the value(s) of $error_caption . - format_logfile - Log files store the entire output of all apps being installed or uninstalled. This function formats the logfile to improve its readability. - Unwanted patterns are removed, like terminal color-codes, long arrays of periods, etc. - All instances of the \\r character are replaced by the \\n character. - A header is added to the file, containing the output from get_device_info . - send_error_report - Sends a log file to the Pi-Apps developers. - send_error_report_gui - A graphical front-end for send_error_report - asks the user permission before sending an error log. - Please note that this is currently not being used. The manage script has its own error-reporting gui and directly uses send_error_report . Below are all functions that don't have anything to do with apps. - runonce - this function runs code only once, ever. Used by other scripts to run one-time workarounds to ensure a smooth transition as Pi-Apps evolves. - For example, this is a real usage of runonce in the Pi-Apps gui script: bash #ensure curl is installed runonce <<\"EOF\" if ! command -v curl >/dev/null ;then sudo apt install -y curl fi EOF It installs curl on the system, but only tries once. - This works by hashing the entire command first, using sha256sum . - If the hash matches a line in the data/runonce_hashes file, nothing occurs. Otherwise, the command is executed. - text_editor - Use a text editor to open a file. - This obeys your choice of \"Preferred text editor\". Usage: text_editor /path/to/your.file - view_file - Display a maximized yad window to view a file. This is used to view logfiles. - is_supported_system - determines if your operating system is supported. This returns an exit-code of 0 if supported, otherwise 1 . If any of the below criteria are true, then your system is unsupported: - The kernel matches \"x86\" or \"i686 or \"i386\". - The /proc/version file matches \"Android\". - The operating system's PRETTY_NAME matches \"stretch\", \"wheezy\", \"jessie\", \"manjaro\" or \"Ubuntu 16\". - The kernel matches \"armv6*\". - The script is being run as root . - The system has less than 500MB of free space. - get_device_info - summarizes the current system setup for debug use. - To view the output on your system, run this command: ~/pi-apps/api get_device_info - This function is used in the format_log_file function. - functions_to_files - Takes every function in the api and turns them into their own miniature bash scripts. - This exists purely for developer-convenience. It allows you to handle functions as if they were files. - It creates a folder ( ~/pi-apps/function-files ) and then places files in it. - files_to_functions - Takes every file in the function-files folder and re-combines them. - The resulting output is printed to the terminal. Command interceptors below: - git_clone - Wrapper function for the git clone command with improvements: - Status information is displayed. (\"Downloading XXXXXX repository...\") - git 's output is suppressed. But if the operation fails, its full output will be displayed in the error message. - Before cloning the repo, the destination folder is removed. This prevents the common error \" Fatal: destination path 'XXXXXX' already exists and is not an empty directory. \". - There may be times when an app-script doesn't want the output suppressed, or status information, or the folder removed first. That's why this function is an \"opt-in\" function; script-writers have to consciencely switch to git_clone if they want to. - wget - This function overrides the wget command in all app-scripts. To speed up app-installation, it uses the aria2c tool when possible. Aria2c is faster and more reliable than wget, but it can't be used in all situations. - To determine if aria2c can be used, this function parses all flags given to it. It stores the url and the output filename. - If any flags other than -q , -O , and -qO are passed, wget is used. - If the aria2c command does not exist, wget is used. - If the output is not a file but is being sent to stdout (using the -qO- flag, for example), wget is used. - If aria2c is enabled, it runs with the following flags: -c -x 16 -s 16 -m 10 --retry-wait 30 --console-log-level=error --show-console-readout=false --summary-interval=0 \"$url\" --dir '/' -o \"${file:1}\" --allow-overwrite - If the -q flag was passed, the --quiet flag is sent to aria2c. - Otherwise, if aria2c was ruled out, wget is run as it normally would. - This function is designed to operate seamlessly in 100% of cases. App-developers should not have to even know that this function is really translating wget commands to aria2c - it should operate exactly the same as wget , but faster. - chmod - Wrapper function for the chmod command with status information. - This displays \" Making executable: /path/to/file \". - unzip - Wrapper function for the unzip command with status information. - This displays \" Extracting: /path/to/file \". And with that, we come to the end of functions in the api script. If you see a function that's not listed here, please let us know.","title":"The api script"},{"location":"scripts/the-api-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/api .","title":"Location:"},{"location":"scripts/the-api-script/#purpose","text":"This script is a collection of functions that do various things. Functions are small chunks of bash-code that can be run like a normal command.","title":"Purpose:"},{"location":"scripts/the-api-script/#usage","text":"source ~/pi-apps/api You can now run any of the functions inside the api script as if they were real commands. Alternatively, the api script supports running a single function without being sourced: ~/pi-apps/api apt_lock_wait","title":"Usage:"},{"location":"scripts/the-api-script/#list-of-functions","text":"Note: new functions are added often. If you don't see a function on this list but do see it in the api, please let us know. - error - display a custom message in red and exit with a return code of 1 . Usage: error \"The command 'sudo apt update' failed!\" This is often seen at the end of a command with the || operator: sudo apt update || error \"The command 'sudo apt update' failed!\" - warning - Display a custom message in yellow and prefix it with \"WARNING: \". - Useful for everything where something is wrong but it's not a fatal error. - This function outputs to stderr . - status - Display a custom message in light-blue. - Used by scripts to indicate current status, like \"Downloading...\", \"Extracting...\", and \"Please wait.\" - This function outputs to stderr . - Some scripts don't want the ending newline, so this function allows for flags to be passed to the echo command. Example usage: status -n \"Downloading... \" - status-green - Display a custom message in green. - Used by scripts to indicate the success of an action, like \"Installed FreeCAD successfully\", \"Update complete\", and \"All packages have been purged successfully.\" - This function outputs to stderr . - generate_logo - Displays the Pi-Apps logo in a terminal. - add_english - Ensures an English locale is installed so that log-diagnosing tools can function properly. - This was added in PR #1031 Apt/dpkg/package functions below. apt_lock_wait - waits until apt locks are released. package_info - List everything dpkg knows about the specified package. This retrieves a block of text from the /var/lib/dpkg/status file. package_installed - determine if the specified package is installed. Returns an exit code of 0 if the package is installed, otherwise it returns 1 . package_available - determine if the specified package is able to be installed with apt . This uses grep to search the /var/lib/apt/lists/ folder. Returns an exit code of 0 if the package was found, otherwise it returns 1 . package_dependencies - List the dependencies of a package This simply isolates a line from the output of the package_info function. This is much faster than doing an apt-cache search . less_apt - Reduce the output of an apt operation. Example usage: bash sudo apt update 2>&1 | less_apt apt_update - A wrapper function to run sudo apt update . This will wait for apt locks to be released, handle status information, and display helpful tips if packages are upgradable or autoremovable. Arguments to the function will be passed on to the apt command. Below are three functions that manage the Pi-Apps local APT repository . This is a special folder ( /tmp/pi-apps-local-packages ) used by the install_packages function to handle installing local deb files. Installing local packages from a repository improves dependency-handling, condenses the operation into one apt operation, and allows the packages to be specified in any order. repo_add - Add the specified deb file(s) to the local repository. This simply copies specified files to the /tmp/pi-apps-local-packages folder. repo_referesh - Index the local repository, create a Packages file, and a source.list . At this point, you can make apt use the repository by passing this flag to it: -o Dir::Etc::SourceList=/tmp/pi-apps-local-packages/source.list repo_rm - Removes the local repository. app_to_pkgname - Convert an app-name to an apt -compatible package name. This function generates the name to use for creating dummy apt packages. The naming scheme is: pi-apps-XXXXXXXX (each X can be any lowercase letter or number) View which dummy packages are installed now by running apt search pi-apps- in a terminal. install_packages - Used by apps to install packages. This function is replacing the pkg-install script. Example usage: install_packages package1 /path/to/package2.deb https://example.com/package3.deb package4-* || exit 1 First, each argument is analyzed. If it's a URL, the file is downloaded and added to the local repository. If it's a deb-file, it's added to the local repository. If it contains regex (regular expression, aka the * character), a list of packages is generated using the apt-cache search command. Next, the local repository is initialized. (if necessary) Now an apt_update takes place. It's time to configure and install an empty apt-package that \"depends on\" the packages we want to install. We refer to it as a \"dummy deb\". First the name of the dummy deb is determined, using the app_to_pkgname function. If the dummy deb is already installed, install_packages will inherit its dependencies and then purge the dummy deb. This means that the install-packages function can be used multiple times in an app's script because it's accumulative. The dummy deb is created, packaged, and finally installed. purge-packages - Used by apps to remove packages that they previously installed. This function accepts no arguments. It reads the $app variable, purges its associated dummy deb, and autoremoves any packages that are no longer necessary. get_icon_from_package - Given a package (or space-separated list of packages), this function will automatically find the program icon for it. This is useful for the createapp script to automatically find a suitable icon for package-apps you're trying to add. This uses dpkg-query to list all files each package installed. The list is filteres to only show .png files in /icons/ or /pixmaps/ folders. The list is sorted by filesize to find the picture with the most pixels. End of apt functions. App functions below. list_apps - List all apps that match a given criteria. (In a newline-separated format) list_apps local will list apps that exist locally. list_apps is the same as list_apps local . list_apps app will list all apps, both local and online. list_apps installed will list apps that are currently installed. list_apps corrupted will list apps that are currently corrupted. list_apps disabled will list apps that are currently disabled. list_apps uninstalled will list apps that are currently uninstalled. list_apps have_status will list apps that currently have a known status. (A clean Pi-Apps installation won't have any status files) list_apps missing_status will list apps that don't have status files. list_apps cpu_installable will list apps that have an installation script compatible with your operating system's CPU architecture. If \"app1\" only has an install-64 script but your system is 32-bit, then \"app1\" will be excluded from this list. Likewise, if \"app1\" only has an install-32 script but your system is 64-bit, then \"app1\" will be excluded from this list. list_apps package will list apps that don't have scripts but have a packages file. list_apps standard will list apps that do have scripts and don't have a packages file. list_apps hidden will list apps that are in the special \"hidden\" category. list_apps visible will list apps that are not in the special \"hidden\" category. list_apps online will list apps that exist in the update/pi-apps/apps folder. list_apps online_only will list apps that are only in the update/pi-apps/apps folder. list_apps local_only will list apps that are not in the update/pi-apps/apps folder. list_intersect - Takes two lists of apps and intersects them, meaning that only apps that are listed in both lists are returned. For example, this will show apps that are both cpu_installable and visible: list_apps cpu_installable | list_intersect \"$(list_apps visible)\" list_subtract - Takes two lists of apps and subtracts one from other, meaning that only apps listed in the first list and not in the second list, are returned. For example, this will show apps that are not compatible with your system's architecture: list_apps local | list_subtract \"$(list_apps cpu_installable)\" read_category_files - Generates a list of categories; data compiled from the data/category-overrides and etc/categories files, with added support for unlisted apps. app_categories - Format the categories file, then list all apps, as if they were inside folders, based on the categories file. Also lists all apps under special \"Installed\" and \"All Apps\" categories. bitly_link - Increase/decrease the \"number of users\" a certain app has. Botspot creates bitly links for every app: one link for installing it, and one link for uninstalling it. Bitly will track how many times each link has been clicked. Assuming the \"Enable Analytics\" setting was not turned off, this function will \"click\" one of those links. Botspot uses a script to upload bitly's statistics to the pi-apps-analytics repository. usercount - returns the number of users an app has, based on the current number in the pi-apps-analytics repository. To display the number of users for the Arduino app: usercount Arduino script_name - returns name of install script(s) for the specified app. Possible outputs: '', 'install', 'install-32', 'install-64', 'install-32 install-64' Usage: script_name Arduino script_name_cpu - Given an app, this returns the name of the app's installation script that would be run if you ran it. For example, if your operating system is 32-bit and the app has an install-32 script, this function would return \"install-32\". If your operating system is 64-bit and the app has an install-64 script, this function would return \"install-64\". If the app has an install script, this function would return \"install\". If none of the above, don't return anything. app_status - return the given app's current status. If the app's status file does not exist, this function returns 'uninstalled'. Otherwise, this function returns the contents of the app's status file. app_type - Determine if an app is a standard app or if it's a package . will_reinstall - Return an exit code of 0 if the specified app would be reinstalled during an update, otherwise return an exit code of 1 . If the app's existing installation script is not identical to the new version of the installation script, AND the app is currently installed, exit with a code of 0 , otherwise exit 1 . app_search - Search all apps for the specified search query. In each app-folder, this will search for matches in the following files: description credits website It hides incompatible and invisible apps before displaying the results. (list of app names, one per line) app_search_gui - A graphical front-end for the app_search function. This displays all results from app_search in a graphical list. One app should be selected from the list before clicking OK. If only one app is displayed in the list, no need to select it. The chosen app (if any) is returned. generate_app_icons - Resize a specified image and place the icons in the specified app-folder. This requires imagemagick to be installed. If it's missing, a dialog box will appear and ask permission to install it. Example usage: generate_app_icons /path/to/my-image.png my-app refresh_pkgapp_status - For the specified package-app, if dpkg thinks it's installed, then mark it as installed. refresh_all_pkgapp_status - For every package-app, if dpkg thinks it's installed, then mark it as installed. Logfile functions below. - get_logfile - Find the most recent logfile for the specified app. - log_diagnose - Search a specified logfile for phrases that indicate non-errors. - Many errors are not Pi-Apps's fault. Most are outside of Pi-Apps's control, but caused by user-interference, Internet problems, or apt configuration errors. - Errors are categorized into three types: system , internet , package , and unknown. - If a known phrase is identified, the $error_type variable is set to either system or internet or package . - If no phrases were identified, the $error_type variable will be set to unknown . Only when the error_type is \"unknown\" will Pi-Apps allow the user to send an error report. - Each detected error has an accompanying caption for the user to read. This caption explains what the problem is and how to fix it. - As multiple error messages might be identified, the error captions are stored in an array variable called $error_caption . Storing explanations in an array allows multiple explanations to be displayed to the user. - Before exiting, this function returns the collected information. The first line is the value of $error_type , while subsequent lines are the value(s) of $error_caption . - format_logfile - Log files store the entire output of all apps being installed or uninstalled. This function formats the logfile to improve its readability. - Unwanted patterns are removed, like terminal color-codes, long arrays of periods, etc. - All instances of the \\r character are replaced by the \\n character. - A header is added to the file, containing the output from get_device_info . - send_error_report - Sends a log file to the Pi-Apps developers. - send_error_report_gui - A graphical front-end for send_error_report - asks the user permission before sending an error log. - Please note that this is currently not being used. The manage script has its own error-reporting gui and directly uses send_error_report . Below are all functions that don't have anything to do with apps. - runonce - this function runs code only once, ever. Used by other scripts to run one-time workarounds to ensure a smooth transition as Pi-Apps evolves. - For example, this is a real usage of runonce in the Pi-Apps gui script: bash #ensure curl is installed runonce <<\"EOF\" if ! command -v curl >/dev/null ;then sudo apt install -y curl fi EOF It installs curl on the system, but only tries once. - This works by hashing the entire command first, using sha256sum . - If the hash matches a line in the data/runonce_hashes file, nothing occurs. Otherwise, the command is executed. - text_editor - Use a text editor to open a file. - This obeys your choice of \"Preferred text editor\". Usage: text_editor /path/to/your.file - view_file - Display a maximized yad window to view a file. This is used to view logfiles. - is_supported_system - determines if your operating system is supported. This returns an exit-code of 0 if supported, otherwise 1 . If any of the below criteria are true, then your system is unsupported: - The kernel matches \"x86\" or \"i686 or \"i386\". - The /proc/version file matches \"Android\". - The operating system's PRETTY_NAME matches \"stretch\", \"wheezy\", \"jessie\", \"manjaro\" or \"Ubuntu 16\". - The kernel matches \"armv6*\". - The script is being run as root . - The system has less than 500MB of free space. - get_device_info - summarizes the current system setup for debug use. - To view the output on your system, run this command: ~/pi-apps/api get_device_info - This function is used in the format_log_file function. - functions_to_files - Takes every function in the api and turns them into their own miniature bash scripts. - This exists purely for developer-convenience. It allows you to handle functions as if they were files. - It creates a folder ( ~/pi-apps/function-files ) and then places files in it. - files_to_functions - Takes every file in the function-files folder and re-combines them. - The resulting output is printed to the terminal. Command interceptors below: - git_clone - Wrapper function for the git clone command with improvements: - Status information is displayed. (\"Downloading XXXXXX repository...\") - git 's output is suppressed. But if the operation fails, its full output will be displayed in the error message. - Before cloning the repo, the destination folder is removed. This prevents the common error \" Fatal: destination path 'XXXXXX' already exists and is not an empty directory. \". - There may be times when an app-script doesn't want the output suppressed, or status information, or the folder removed first. That's why this function is an \"opt-in\" function; script-writers have to consciencely switch to git_clone if they want to. - wget - This function overrides the wget command in all app-scripts. To speed up app-installation, it uses the aria2c tool when possible. Aria2c is faster and more reliable than wget, but it can't be used in all situations. - To determine if aria2c can be used, this function parses all flags given to it. It stores the url and the output filename. - If any flags other than -q , -O , and -qO are passed, wget is used. - If the aria2c command does not exist, wget is used. - If the output is not a file but is being sent to stdout (using the -qO- flag, for example), wget is used. - If aria2c is enabled, it runs with the following flags: -c -x 16 -s 16 -m 10 --retry-wait 30 --console-log-level=error --show-console-readout=false --summary-interval=0 \"$url\" --dir '/' -o \"${file:1}\" --allow-overwrite - If the -q flag was passed, the --quiet flag is sent to aria2c. - Otherwise, if aria2c was ruled out, wget is run as it normally would. - This function is designed to operate seamlessly in 100% of cases. App-developers should not have to even know that this function is really translating wget commands to aria2c - it should operate exactly the same as wget , but faster. - chmod - Wrapper function for the chmod command with status information. - This displays \" Making executable: /path/to/file \". - unzip - Wrapper function for the unzip command with status information. - This displays \" Extracting: /path/to/file \". And with that, we come to the end of functions in the api script. If you see a function that's not listed here, please let us know.","title":"List of functions:"},{"location":"scripts/the-categoryedit-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/categoryedit . This file is located in the etc folder because it's one of the smaller scripts. Purpose: Manage Pi-Apps categories. As of commit https://github.com/Botspot/pi-apps/commit/ab1fcb5a114ab720df1712aaf151a9733e18a94c, there are two categories files: a local one and a global one. The global file is kept updated like any other file, while the local file is empty by default but can contain overrides . The global categories file: /home/pi/pi-apps/etc/categories The local categories file: /home/pi/pi-apps/data/category-overrides Usage: Run the category editor: ~/pi-apps/etc/categoryedit Move the Arduino app to the Internet category: ~/pi-apps/etc/categoryedit Arduino Internet Move the Arduino app to the top level (no category): ~/pi-apps/etc/categoryedit Arduino","title":"The categoryedit script"},{"location":"scripts/the-categoryedit-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/categoryedit . This file is located in the etc folder because it's one of the smaller scripts.","title":"Location:"},{"location":"scripts/the-categoryedit-script/#purpose","text":"Manage Pi-Apps categories. As of commit https://github.com/Botspot/pi-apps/commit/ab1fcb5a114ab720df1712aaf151a9733e18a94c, there are two categories files: a local one and a global one. The global file is kept updated like any other file, while the local file is empty by default but can contain overrides . The global categories file: /home/pi/pi-apps/etc/categories The local categories file: /home/pi/pi-apps/data/category-overrides","title":"Purpose:"},{"location":"scripts/the-categoryedit-script/#usage","text":"Run the category editor: ~/pi-apps/etc/categoryedit Move the Arduino app to the Internet category: ~/pi-apps/etc/categoryedit Arduino Internet Move the Arduino app to the top level (no category): ~/pi-apps/etc/categoryedit Arduino","title":"Usage:"},{"location":"scripts/the-createapp-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/createapp . Purpose: A GUI to help you create/edit an app. Usage: To create a new app: ~/pi-apps/createapp To edit an existing app: ~/pi-apps/createapp Arduino How it works: This script is one long while loop with a case statement for each step. (similar to the gui script) Each dialog allows you to go forward or backward and the current step is stored in the $step variable. That's about it. View the script to see how each step works.","title":"The createapp script"},{"location":"scripts/the-createapp-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/createapp .","title":"Location:"},{"location":"scripts/the-createapp-script/#purpose","text":"A GUI to help you create/edit an app.","title":"Purpose:"},{"location":"scripts/the-createapp-script/#usage","text":"To create a new app: ~/pi-apps/createapp To edit an existing app: ~/pi-apps/createapp Arduino","title":"Usage:"},{"location":"scripts/the-createapp-script/#how-it-works","text":"This script is one long while loop with a case statement for each step. (similar to the gui script) Each dialog allows you to go forward or backward and the current step is stored in the $step variable. That's about it. View the script to see how each step works.","title":"How it works:"},{"location":"scripts/the-gui-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/gui . Purpose: This script handles Pi-Apps's entire user-interface. Usage: To run Pi-Apps: ~/pi-apps/gui To start Pi-Apps at a specific app: ~/pi-apps/gui Arduino To start Pi-Apps on a specific category: ~/pi-apps/gui 'All Apps/' How it works: The splash screen appears. The api script is sourced. The pi-apps logo is displayed in the terminal (using the generate_logo function) A series of runonce entries are executed in the background. The message of the day is determined. To save time, it's stored in data/announcements . If that file is missing or it's more than a day old, it is downloaded from the pi-apps-announcements repository . One random line is taken from the file and used as the message for this session. We now come to a while loop that runs the GUI. Inside is an if statement that obeys the following values of the $action variable: main-window - Handles the app list. This may be a yad window or an xlunch window, depending on the \"App List Style\" setting. Xlunch is compiled, if necessary. details - Displays the details of the current app. search - Sets the $app variable to the output of the app_search_gui function. The rest of the modes need no explanation. They are: exit , back , install , uninstall , scripts , edit , credits , enable , viewlog , mind-reading , view-updates , unknown .","title":"The gui script"},{"location":"scripts/the-gui-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/gui .","title":"Location:"},{"location":"scripts/the-gui-script/#purpose","text":"This script handles Pi-Apps's entire user-interface.","title":"Purpose:"},{"location":"scripts/the-gui-script/#usage","text":"To run Pi-Apps: ~/pi-apps/gui To start Pi-Apps at a specific app: ~/pi-apps/gui Arduino To start Pi-Apps on a specific category: ~/pi-apps/gui 'All Apps/'","title":"Usage:"},{"location":"scripts/the-gui-script/#how-it-works","text":"The splash screen appears. The api script is sourced. The pi-apps logo is displayed in the terminal (using the generate_logo function) A series of runonce entries are executed in the background. The message of the day is determined. To save time, it's stored in data/announcements . If that file is missing or it's more than a day old, it is downloaded from the pi-apps-announcements repository . One random line is taken from the file and used as the message for this session. We now come to a while loop that runs the GUI. Inside is an if statement that obeys the following values of the $action variable: main-window - Handles the app list. This may be a yad window or an xlunch window, depending on the \"App List Style\" setting. Xlunch is compiled, if necessary. details - Displays the details of the current app. search - Sets the $app variable to the output of the app_search_gui function. The rest of the modes need no explanation. They are: exit , back , install , uninstall , scripts , edit , credits , enable , viewlog , mind-reading , view-updates , unknown .","title":"How it works:"},{"location":"scripts/the-logviewer-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/logviewer . This file is located in the etc folder because it's one of the smaller scripts. Purpose: Browse the list of log files, opening any files that you click on with the viewlog script. Usage: ~/pi-apps/etc/logviewer","title":"The logviewer script"},{"location":"scripts/the-logviewer-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/logviewer . This file is located in the etc folder because it's one of the smaller scripts.","title":"Location:"},{"location":"scripts/the-logviewer-script/#purpose","text":"Browse the list of log files, opening any files that you click on with the viewlog script.","title":"Purpose:"},{"location":"scripts/the-logviewer-script/#usage","text":"~/pi-apps/etc/logviewer","title":"Usage:"},{"location":"scripts/the-manage-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/manage . Purpose: The manage script will install apps, uninstall apps, and update apps. It can be compared to the apt tool on Debian Linux. Usage: The manage script won't do much if you run it standalone: $ ~/pi-apps/manage You need to specify an operation, and in most cases, which app to operate on. You need to tell the manage script to do something. $ ~/pi-apps/manage install Arduino Now we're getting somewhere! You just installed the Arduino app. The manage script supports these modes : - install : installs the specified app. Several things occur before the app's installation script is run: - The specified app must exist. - The app must not be disabled. If it is, the manage script exits with an exit-code of zero. - If your system is unsupported (determined by the is_supported_system function in the api script), a warning will appear, along with a 10-second wait-time. - The app's installation script is determined. Depending on the app and on your system's CPU architecture, the script-name may be \" install \", \" install-32 \", or \" install-64 \". - Determine a unique filename for the log-file to be generated. (This file will store the entire output of the installation process.) - Finally, the app's installation script is executed. - It is executed with the nice command, to lower the priority of the process so that the rest of the system remains responsive, even while compiling. - Its output is redirected to the log-file, and to stdout. (usually the terminal) - If the app's installation script succeeded (if it exited with a return code of 0 ): - The the log-file is renamed to install-success-$app - The manage script exits with a return code of 0 . - However, if the app's installation script failed (any return code except 0 ): - The the log-file will be renamed to install-fail-$app . - The manage script exits with a return code of 1 . - uninstall : exactly like the install mode except that it uninstalls the specified app. - These two modes are so similar that they share the same code! - install-if-not-installed : Installs the specified app, only if it has not already been installed. - This mode is especially useful for apps that need another app to be installed first . For example, the Wine (x86) app requires Box86. It accomplishes that with this comand: bash \"${DIRECTORY}/manage\" install-if-not-installed Box86 || error \"Box86 failed to install somehow!\" - multi-install : installs multiple apps, one at a time. How to specify multiple apps? By using a multi-line argument , like this: bash $ ~/pi-apps/manage multi-install \"Arduino BalenaEtcher CloudBuddy Downgrade Chromium\" Note about multi-install : This mode includes elements. - Before installing anything, manage will check if any apps are already installed . If so, a yad dialog will appear and ask if you really want to install that app again. - If you choose \"No\", the app is removed from the list of apps to install. - Then, each app will be installed, one at a time. - It does this by running the manage script in the install mode, once for each app - If any apps fail to install, a yad dialog will appear and ask permission to send the error log to Pi-Apps developers. - multi-uninstall : exactly like multi-install except that it uninstalls the list of apps. - These two modes are so similar that they share the same code! - check-all : This mode is the Pi-Apps equivalent to an apt update . It lists updatable apps. - It downloads the latest pi-apps repository to the update/pi-apps folder. (using git clone or git pull , as appropriate) Now, there are two versions of Pi-Apps on the local filesystem: the \" local version \" and the \" latest version \". - Each app-folder is compared. - If the app-folder only exists in the local version, then no action is taken. - If the app-folder only exists in the online version, then it must be a new app and is added to the list of updatable apps. - If the app-folder exists in both locations and the contents do match , then no action is taken. - If the app-folder exists in both locations but the contents don't match , the online version must have received an update. As a result, the app is added to the list of updatable apps. - Finally, the list of updatable apps (one app per line) is written to standard output and the script exits. - update : This mode will update a single app. (like an apt upgrade ) It copies the new version from the update folder to the main folder, reinstalling if necessary. - First, the app may need to be installed, or it may not: - If the app is currently installed, and its current installation script does not match the online version, then the app is uninstalled. - Then the current (old) app-folder is sent to the system's Trash folder. - This is a failsafe: just in case you made changes to the app-folder, you have an option to restore those changes. (as opposed to permanent deletion) - The app-folder is copied from the update/pi-apps/apps folder to the main apps folder. - If the app was uninstalled earlier, it will now be installed back. - update-all : This mode will check for app-updates and install them without any user-interaction. The manage script will run itself in the check-all mode, then, for every app that check-all mentioned, it will update each app.","title":"The manage script"},{"location":"scripts/the-manage-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/manage .","title":"Location:"},{"location":"scripts/the-manage-script/#purpose","text":"The manage script will install apps, uninstall apps, and update apps. It can be compared to the apt tool on Debian Linux.","title":"Purpose:"},{"location":"scripts/the-manage-script/#usage","text":"The manage script won't do much if you run it standalone: $ ~/pi-apps/manage You need to specify an operation, and in most cases, which app to operate on. You need to tell the manage script to do something. $ ~/pi-apps/manage install Arduino Now we're getting somewhere! You just installed the Arduino app. The manage script supports these modes : - install : installs the specified app. Several things occur before the app's installation script is run: - The specified app must exist. - The app must not be disabled. If it is, the manage script exits with an exit-code of zero. - If your system is unsupported (determined by the is_supported_system function in the api script), a warning will appear, along with a 10-second wait-time. - The app's installation script is determined. Depending on the app and on your system's CPU architecture, the script-name may be \" install \", \" install-32 \", or \" install-64 \". - Determine a unique filename for the log-file to be generated. (This file will store the entire output of the installation process.) - Finally, the app's installation script is executed. - It is executed with the nice command, to lower the priority of the process so that the rest of the system remains responsive, even while compiling. - Its output is redirected to the log-file, and to stdout. (usually the terminal) - If the app's installation script succeeded (if it exited with a return code of 0 ): - The the log-file is renamed to install-success-$app - The manage script exits with a return code of 0 . - However, if the app's installation script failed (any return code except 0 ): - The the log-file will be renamed to install-fail-$app . - The manage script exits with a return code of 1 . - uninstall : exactly like the install mode except that it uninstalls the specified app. - These two modes are so similar that they share the same code! - install-if-not-installed : Installs the specified app, only if it has not already been installed. - This mode is especially useful for apps that need another app to be installed first . For example, the Wine (x86) app requires Box86. It accomplishes that with this comand: bash \"${DIRECTORY}/manage\" install-if-not-installed Box86 || error \"Box86 failed to install somehow!\" - multi-install : installs multiple apps, one at a time. How to specify multiple apps? By using a multi-line argument , like this: bash $ ~/pi-apps/manage multi-install \"Arduino BalenaEtcher CloudBuddy Downgrade Chromium\" Note about multi-install : This mode includes elements. - Before installing anything, manage will check if any apps are already installed . If so, a yad dialog will appear and ask if you really want to install that app again. - If you choose \"No\", the app is removed from the list of apps to install. - Then, each app will be installed, one at a time. - It does this by running the manage script in the install mode, once for each app - If any apps fail to install, a yad dialog will appear and ask permission to send the error log to Pi-Apps developers. - multi-uninstall : exactly like multi-install except that it uninstalls the list of apps. - These two modes are so similar that they share the same code! - check-all : This mode is the Pi-Apps equivalent to an apt update . It lists updatable apps. - It downloads the latest pi-apps repository to the update/pi-apps folder. (using git clone or git pull , as appropriate) Now, there are two versions of Pi-Apps on the local filesystem: the \" local version \" and the \" latest version \". - Each app-folder is compared. - If the app-folder only exists in the local version, then no action is taken. - If the app-folder only exists in the online version, then it must be a new app and is added to the list of updatable apps. - If the app-folder exists in both locations and the contents do match , then no action is taken. - If the app-folder exists in both locations but the contents don't match , the online version must have received an update. As a result, the app is added to the list of updatable apps. - Finally, the list of updatable apps (one app per line) is written to standard output and the script exits. - update : This mode will update a single app. (like an apt upgrade ) It copies the new version from the update folder to the main folder, reinstalling if necessary. - First, the app may need to be installed, or it may not: - If the app is currently installed, and its current installation script does not match the online version, then the app is uninstalled. - Then the current (old) app-folder is sent to the system's Trash folder. - This is a failsafe: just in case you made changes to the app-folder, you have an option to restore those changes. (as opposed to permanent deletion) - The app-folder is copied from the update/pi-apps/apps folder to the main apps folder. - If the app was uninstalled earlier, it will now be installed back. - update-all : This mode will check for app-updates and install them without any user-interaction. The manage script will run itself in the check-all mode, then, for every app that check-all mentioned, it will update each app.","title":"Usage:"},{"location":"scripts/the-pkg-install-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/pkg-install . Purpose: Some background information first: - Goal: Pi-Apps is designed for people who install an app, try it out, then later uninstall it. You should not have to think twice before installing an app. Users should have confidence that uninstalling the app will undo all changes and restore all disk-space. - Problem: Many apps need to install apt packages in order to work. On the surface, this does not seem like a big problem at all: if \"app1\" installs \"package1\", \"package2\", and \"package3\", then those packages should be purged while uninstalling \"app1\". What's the problem with that? Dependencies. What if some other utility requires \"package1\" to function? Now that you uninstalled \"app1\", \"package1\" just got uninstalled. - Best-case scenario: that utility will not work anymore. - Worst-case scenario: you just broke an essential part of your system and it will fail to boot. - Solution: When uninstalling an app, only remove packages that are not required by anything else . To accomplish this, we can't just install packages the normal way with sudo apt install . Instead, we need to generate a dummy deb - a custom apt package that lists \"package1\", \"package2\", and \"package3\" as dependencies . Later, when the app is being uninstalled, the dummy deb is removed and a simple apt autoremove is enough to safely remove the packages. Usage: In an app's install script, there may be a line like this to install \"package1\", \"package2\", and \"package3\": DIRECTORY=$HOME/pi-apps \"${DIRECTORY}/pkg-install\" 'package1 package2 package3' \"$(dirname \"$0\")\" || exit 1 This is equivalent to: sudo apt update --allow-releaseinfo-change sudo apt install -yf --no-install-recommends --allow-downgrades package1 package2 package3 How it works: First, pkg-install sets the language variables to C . This ensures that apt's output is parsed correctly, even if the system is using a different language, pkg-install runs sudo apt update . The output of sudo apt update is parsed for various messages from apt . If the output contains \"autoremove to remove them\", you will receive a message that some packages can be removed with apt autoremove . If the output contains \"packages can be upgraded\", you will receive a message that some packages can be upgraded. If the output contains \"W:\" or \"E:\" or \"Err:\", pkg-install will exit with an error saying that your apt system is messed up. The exact error message depends on apt's exact output - it is designed to help users navigate through apt errors and provides instructions for how to sign a repository, remove a broken repository, or check for an Internet connection. If any filenames (paths to a local deb package) are specified, pkg-install will install each one, then mark it as autoremovable. (Using this command: sudo apt-mark auto \"$packagename\" If any package names include regular expression , pkg-install expands the names with apt-cache search . Finally, the dummy deb is created. As mentioned earlier, this package will list the desired packages as dependencies. The dummy deb for each app has to be named something unique. But this poses a problem because apps can have space characters while apt does not support space characters. This problem is resolved by naming each dummy-deb based on a hash of its name . The code used to do this is: bash echo -n 'pi-apps-' ; echo \"$app\" | md5sum | cut -c1-8 | awk '{print $1}' Feel free to replace \"$app\" with an app-name of your choice to see what its package name would be. If the dummy deb's name is already installed, purge it and then continue. Finally, the dummy deb is installed with apt . All packages mentioned in the \" Depends: \" field of the dummy deb are installed as a dependency of the dummy deb. If apt fails, its errors are diagnosed in the same way errors were diagnosed earlier when sudo apt update was run. pkg-install exits with a code of 0 if everything was successful, otherwise it exits with a code of 1 .","title":"The pkg install script"},{"location":"scripts/the-pkg-install-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/pkg-install .","title":"Location:"},{"location":"scripts/the-pkg-install-script/#purpose","text":"Some background information first: - Goal: Pi-Apps is designed for people who install an app, try it out, then later uninstall it. You should not have to think twice before installing an app. Users should have confidence that uninstalling the app will undo all changes and restore all disk-space. - Problem: Many apps need to install apt packages in order to work. On the surface, this does not seem like a big problem at all: if \"app1\" installs \"package1\", \"package2\", and \"package3\", then those packages should be purged while uninstalling \"app1\". What's the problem with that? Dependencies. What if some other utility requires \"package1\" to function? Now that you uninstalled \"app1\", \"package1\" just got uninstalled. - Best-case scenario: that utility will not work anymore. - Worst-case scenario: you just broke an essential part of your system and it will fail to boot. - Solution: When uninstalling an app, only remove packages that are not required by anything else . To accomplish this, we can't just install packages the normal way with sudo apt install . Instead, we need to generate a dummy deb - a custom apt package that lists \"package1\", \"package2\", and \"package3\" as dependencies . Later, when the app is being uninstalled, the dummy deb is removed and a simple apt autoremove is enough to safely remove the packages.","title":"Purpose:"},{"location":"scripts/the-pkg-install-script/#usage","text":"In an app's install script, there may be a line like this to install \"package1\", \"package2\", and \"package3\": DIRECTORY=$HOME/pi-apps \"${DIRECTORY}/pkg-install\" 'package1 package2 package3' \"$(dirname \"$0\")\" || exit 1 This is equivalent to: sudo apt update --allow-releaseinfo-change sudo apt install -yf --no-install-recommends --allow-downgrades package1 package2 package3","title":"Usage:"},{"location":"scripts/the-pkg-install-script/#how-it-works","text":"First, pkg-install sets the language variables to C . This ensures that apt's output is parsed correctly, even if the system is using a different language, pkg-install runs sudo apt update . The output of sudo apt update is parsed for various messages from apt . If the output contains \"autoremove to remove them\", you will receive a message that some packages can be removed with apt autoremove . If the output contains \"packages can be upgraded\", you will receive a message that some packages can be upgraded. If the output contains \"W:\" or \"E:\" or \"Err:\", pkg-install will exit with an error saying that your apt system is messed up. The exact error message depends on apt's exact output - it is designed to help users navigate through apt errors and provides instructions for how to sign a repository, remove a broken repository, or check for an Internet connection. If any filenames (paths to a local deb package) are specified, pkg-install will install each one, then mark it as autoremovable. (Using this command: sudo apt-mark auto \"$packagename\" If any package names include regular expression , pkg-install expands the names with apt-cache search . Finally, the dummy deb is created. As mentioned earlier, this package will list the desired packages as dependencies. The dummy deb for each app has to be named something unique. But this poses a problem because apps can have space characters while apt does not support space characters. This problem is resolved by naming each dummy-deb based on a hash of its name . The code used to do this is: bash echo -n 'pi-apps-' ; echo \"$app\" | md5sum | cut -c1-8 | awk '{print $1}' Feel free to replace \"$app\" with an app-name of your choice to see what its package name would be. If the dummy deb's name is already installed, purge it and then continue. Finally, the dummy deb is installed with apt . All packages mentioned in the \" Depends: \" field of the dummy deb are installed as a dependency of the dummy deb. If apt fails, its errors are diagnosed in the same way errors were diagnosed earlier when sudo apt update was run. pkg-install exits with a code of 0 if everything was successful, otherwise it exits with a code of 1 .","title":"How it works:"},{"location":"scripts/the-preload-daemon-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/preload-daemon . This file is located in the etc folder because it's one of the smaller scripts. Purpose: To generate the app-list for all categories. Usage: Preload all categories for yad , repeating every 30 seconds for a total of 20 times: ~/pi-apps/etc/preload-daemon yad Preload all categories for xlunch only once: ~/pi-apps/etc/preload-daemon xlunch once","title":"The preload daemon script"},{"location":"scripts/the-preload-daemon-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/preload-daemon . This file is located in the etc folder because it's one of the smaller scripts.","title":"Location:"},{"location":"scripts/the-preload-daemon-script/#purpose","text":"To generate the app-list for all categories.","title":"Purpose:"},{"location":"scripts/the-preload-daemon-script/#usage","text":"Preload all categories for yad , repeating every 30 seconds for a total of 20 times: ~/pi-apps/etc/preload-daemon yad Preload all categories for xlunch only once: ~/pi-apps/etc/preload-daemon xlunch once","title":"Usage:"},{"location":"scripts/the-preload-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/preload . Purpose: To generate the app-list for a given category, and prioritizing minimum execution-time. Usage: To generate the app-list of the \"Installed\" category for yad: ~/pi-apps/preload yad 'Installed' To generate the app-list for xlunch for the main page (no category) ~/pi-apps/preload /home/pi/pi-apps/preload xlunch '' How it works: This script is designed for maximum speed. As a result, it uses many tricks to run faster. 1. Compile the genapplist-yad program. This is a C program designed to improve preloading times, but if it fails, a bash-based fallback is used. - It uses gcc to compile the /etc/genapplist-yad.c file to the /etc/genapplist-yad binary. - This program is tested; if it fails to produce 5 lines of output for one input app, the program is deleted to use the bash-based fallback. 2. Determine if it's necessary to generate the app-list. - If nothing has been modified in the apps folder, the settings folder, the update-status folder, the etc folder, the api script, the preload script, and the categories file, skip generating the app-list, return the contents of the previous app-list in the data/preload folder, and exit . 3. If it is necessary to generate the app-list, use the app_categories function to generate a list of all apps in their respective categories. 4. Limit the list of apps to the current category. (so if we're viewing the \"Installed\" category, hide all apps that are not in there.) 5. If the \"Shuffle App list\" setting is enabled, shuffle the list of apps and categories now. - Note: categories are always displayed above apps. 6. Remove apps that are not compatible with the operating system's CPU architecture. 7. Generate the list of visible categories. 8. Generate the list of visible apps. - If the GUI-mode is yad, use the genapplist-yad program if it exists. - Otherwise, generate the list of apps the slower bash-based way. 9. Save the resulting app-list to a file in the data/preload folder. (so that next time preload is run, it might not have to generate anything) 10. In the background, place all app-icons in the disk cache. This improves load-time. 11. Output the resulting app-list. 12. Run the preload-daemon script in the background to preload other categories. That way, when using Pi-Apps, by the time you click any category, it has just been preloaded and is ready-to-go.","title":"The preload script"},{"location":"scripts/the-preload-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/preload .","title":"Location:"},{"location":"scripts/the-preload-script/#purpose","text":"To generate the app-list for a given category, and prioritizing minimum execution-time.","title":"Purpose:"},{"location":"scripts/the-preload-script/#usage","text":"To generate the app-list of the \"Installed\" category for yad: ~/pi-apps/preload yad 'Installed' To generate the app-list for xlunch for the main page (no category) ~/pi-apps/preload /home/pi/pi-apps/preload xlunch ''","title":"Usage:"},{"location":"scripts/the-preload-script/#how-it-works","text":"This script is designed for maximum speed. As a result, it uses many tricks to run faster. 1. Compile the genapplist-yad program. This is a C program designed to improve preloading times, but if it fails, a bash-based fallback is used. - It uses gcc to compile the /etc/genapplist-yad.c file to the /etc/genapplist-yad binary. - This program is tested; if it fails to produce 5 lines of output for one input app, the program is deleted to use the bash-based fallback. 2. Determine if it's necessary to generate the app-list. - If nothing has been modified in the apps folder, the settings folder, the update-status folder, the etc folder, the api script, the preload script, and the categories file, skip generating the app-list, return the contents of the previous app-list in the data/preload folder, and exit . 3. If it is necessary to generate the app-list, use the app_categories function to generate a list of all apps in their respective categories. 4. Limit the list of apps to the current category. (so if we're viewing the \"Installed\" category, hide all apps that are not in there.) 5. If the \"Shuffle App list\" setting is enabled, shuffle the list of apps and categories now. - Note: categories are always displayed above apps. 6. Remove apps that are not compatible with the operating system's CPU architecture. 7. Generate the list of visible categories. 8. Generate the list of visible apps. - If the GUI-mode is yad, use the genapplist-yad program if it exists. - Otherwise, generate the list of apps the slower bash-based way. 9. Save the resulting app-list to a file in the data/preload folder. (so that next time preload is run, it might not have to generate anything) 10. In the background, place all app-icons in the disk cache. This improves load-time. 11. Output the resulting app-list. 12. Run the preload-daemon script in the background to preload other categories. That way, when using Pi-Apps, by the time you click any category, it has just been preloaded and is ready-to-go.","title":"How it works:"},{"location":"scripts/the-purge-installed-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/purge-installed . Purpose: This script is the opposite of pkg-install : it uninstalls the dummy deb, then runs sudo apt autoremove . Usage: In an app's uninstall script, there may be a line like this: DIRECTORY=$HOME/pi-apps \"${DIRECTORY}/purge-installed\" \"$(dirname \"$0\")\" || exit 1","title":"The purge installed script"},{"location":"scripts/the-purge-installed-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/purge-installed .","title":"Location:"},{"location":"scripts/the-purge-installed-script/#purpose","text":"This script is the opposite of pkg-install : it uninstalls the dummy deb, then runs sudo apt autoremove .","title":"Purpose:"},{"location":"scripts/the-purge-installed-script/#usage","text":"In an app's uninstall script, there may be a line like this: DIRECTORY=$HOME/pi-apps \"${DIRECTORY}/purge-installed\" \"$(dirname \"$0\")\" || exit 1","title":"Usage:"},{"location":"scripts/the-settings-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/settings . Purpose: To manage settings for Pi-Apps. Usage: To launch the graphical settings window: ~/pi-apps/settings To check for missing setting-values and fill them with the default values, use this flag: ~/pi-apps/settings refresh To revert all settings to their default values: ~/pi-apps/settings revert How it works: Each setting is stored in two places in the main pi-apps folder: - The setting's possible values, default value, and explanation is stored in the etc/setting-params folder. - For example, the etc/setting-params/App List Style file contains: #Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch) yad xlunch-dark xlunch-dark-3d xlunch-light-3d - All commented lines are the explanation, also known as the tooltip. - For this file, it is: #Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch) - The first uncommented line is the default value for the setting. - For this file, it is: yad - Subsequent uncommented lines are additional possible values. - For this file, they are: xlunch-dark xlunch-dark-3d xlunch-light-3d - The setting's current value is stored in the data/settings folder. This is a single file that contains a single-line value. - For example, if I set the app list style to \"xlunch-dark-3d\", the data/settings/App List Style file will contain \" xlunch-dark-3d \". This dual-file/dual-folder approach is necessary to retain your choice, while allowing there to be future updates to settings, and/or their possible values. (Remember, the data directory is never updated but the etc folder is.)","title":"The settings script"},{"location":"scripts/the-settings-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/settings .","title":"Location:"},{"location":"scripts/the-settings-script/#purpose","text":"To manage settings for Pi-Apps.","title":"Purpose:"},{"location":"scripts/the-settings-script/#usage","text":"To launch the graphical settings window: ~/pi-apps/settings To check for missing setting-values and fill them with the default values, use this flag: ~/pi-apps/settings refresh To revert all settings to their default values: ~/pi-apps/settings revert","title":"Usage:"},{"location":"scripts/the-settings-script/#how-it-works","text":"Each setting is stored in two places in the main pi-apps folder: - The setting's possible values, default value, and explanation is stored in the etc/setting-params folder. - For example, the etc/setting-params/App List Style file contains: #Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch) yad xlunch-dark xlunch-dark-3d xlunch-light-3d - All commented lines are the explanation, also known as the tooltip. - For this file, it is: #Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch) - The first uncommented line is the default value for the setting. - For this file, it is: yad - Subsequent uncommented lines are additional possible values. - For this file, they are: xlunch-dark xlunch-dark-3d xlunch-light-3d - The setting's current value is stored in the data/settings folder. This is a single file that contains a single-line value. - For example, if I set the app list style to \"xlunch-dark-3d\", the data/settings/App List Style file will contain \" xlunch-dark-3d \". This dual-file/dual-folder approach is necessary to retain your choice, while allowing there to be future updates to settings, and/or their possible values. (Remember, the data directory is never updated but the etc folder is.)","title":"How it works:"},{"location":"scripts/the-terminal-run-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/terminal-run . This file is located in the etc folder because it's one of the smaller scripts. Purpose: This script may be Botspot's greatest contribution to the open-source world . Apart from this script, there is no reliable way to: - Run a newline-separated list of commands in a new terminal window. - Set the terminal's title, as desired. - Keep the script running until the terminal has been closed. - Support a variety of terminals. Usage: This command will run two commands in a terminal and set the terminal's title to \"Upgrading your packages\": ~/pi-apps/etc/terminal-run 'sudo apt update sudo apt upgrade' \"Upgrading your packages\" The terminal-run script will not exit until the terminal closes. How it works: As mentioned earlier, this script supports running a list of commands in a terminal. That may sound easy enough, but it's not. - Terminals are not designed to support this. Most terminals can, with some clever tricks, but it varies on a case-by-case basis. As mentioned earlier, this script will keep running until the terminal has been closed. How is that possible? - Before running any commands in a terminal, a special file is created in the /tmp folder. This file is empty for now. - Then, the terminal is instructed to write its PID (process ID) to the file . - Now, while the terminal is running, the terminal-run script can regularly check if that PID process is still running. - It does this by periodically checking if the /proc/${PID} folder exists. - When the PID stops, it indicates that the terminal has been closed. Now the terminal-run script exits. Supported terminals: - lxterminal - xfce4-terminal - mate-terminal - xterm - konsole - terminator - gnome-terminal - x-terminal-emulator Debug mode: if you set the DEBUG variable to 1 , terminal-run will output the name of the currently-used terminal. - This is useful for debugging, when no terminal appears and we want to know which terminal was being used.","title":"The terminal run script"},{"location":"scripts/the-terminal-run-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/terminal-run . This file is located in the etc folder because it's one of the smaller scripts.","title":"Location:"},{"location":"scripts/the-terminal-run-script/#purpose","text":"This script may be Botspot's greatest contribution to the open-source world . Apart from this script, there is no reliable way to: - Run a newline-separated list of commands in a new terminal window. - Set the terminal's title, as desired. - Keep the script running until the terminal has been closed. - Support a variety of terminals.","title":"Purpose:"},{"location":"scripts/the-terminal-run-script/#usage","text":"This command will run two commands in a terminal and set the terminal's title to \"Upgrading your packages\": ~/pi-apps/etc/terminal-run 'sudo apt update sudo apt upgrade' \"Upgrading your packages\" The terminal-run script will not exit until the terminal closes.","title":"Usage:"},{"location":"scripts/the-terminal-run-script/#how-it-works","text":"As mentioned earlier, this script supports running a list of commands in a terminal. That may sound easy enough, but it's not. - Terminals are not designed to support this. Most terminals can, with some clever tricks, but it varies on a case-by-case basis. As mentioned earlier, this script will keep running until the terminal has been closed. How is that possible? - Before running any commands in a terminal, a special file is created in the /tmp folder. This file is empty for now. - Then, the terminal is instructed to write its PID (process ID) to the file . - Now, while the terminal is running, the terminal-run script can regularly check if that PID process is still running. - It does this by periodically checking if the /proc/${PID} folder exists. - When the PID stops, it indicates that the terminal has been closed. Now the terminal-run script exits. Supported terminals: - lxterminal - xfce4-terminal - mate-terminal - xterm - konsole - terminator - gnome-terminal - x-terminal-emulator Debug mode: if you set the DEBUG variable to 1 , terminal-run will output the name of the currently-used terminal. - This is useful for debugging, when no terminal appears and we want to know which terminal was being used.","title":"How it works:"},{"location":"scripts/the-updater-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/updater . Purpose: This script handles Pi-Apps updates, both for apps and for files. Apps do not have version numbers, so updating involves comparing the installation-script of the existing app-folder with the installation-script of the new app-folder. Usage: ~/pi-apps/updater gui This will check for updatable apps and files, then will display them in a graphical list, (using yad of course), and will give you the option to update certain items and not others. But that's not all you can do with this script. The updater script supports multiple modes , useful for a variety of situations: - gui - Check for updates and list them graphically. - This is the default mode if you did not specify one. - If you choose to update anything, a terminal will appear to update apps. - gui-yes - Exactly the same as the gui mode, except that the updates are automatically applied in a terminal. - autostarted or onboot - This mode is intended to be run on boot . - First, determine if the update-interval setting allows an update-check today. - If not, the script exits. - Then, make sure that at least one app has been installed . - This is accomplished by checking if there are any files in the data/status folder. A fresh installation of Pi-Apps will not have any files in that folder, because no apps have been installed yet. - If there are no files in that folder, the script will exit. - After that, assuming there are updates available, display a notification in the lower-right corner of the screen. - This notification is designed to not interfere with typing . - If you click Details , you will see the graphical list of updates, just like with the gui mode. - Once updates are complete, another notification will appear to say \"Pi-Apps updates complete.\" - cli - This mode is intended to be run in a terminal . It checks for updates, lists the updates, and prompts for a Y/N answer. - cli-yes - Check for updates, then automatically apply them all. - set-status - Check for updates and then exit. - The list of updatable apps is written to \"${DIRECTORY}/data/update-status/updatable-apps\" , with the DIRECTORY variable being the location of your Pi-Apps folder. (default: /home/pi/pi-apps ) - The list of updatable files is written to \"${DIRECTORY}/data/update-status/updatable-files\" . - The script will exit with code 0 if updates are available, otherwise 1 . - get-status - Check if an update was available the last time set-status was run. - This is based on the length of the updatable-files and updatable-apps files. - Doing it this way allows for an instant update-check - necessary for a gui to run quickly. Nobody wants to wait for an update-check to finish before Pi-Apps will launch. - The script will exit with code 0 if updates are available, otherwise 1 . Updater also supports a fast mode . This is necessary for the Pi-Apps GUI, where you don't want to wait a few seconds after clicking the \"Updates\" category. Using the fast mode will rely on the previous update-check. It won't check for updates, it will simply display them. To use the fast mode: ~/pi-apps/updater gui fast","title":"The updater script"},{"location":"scripts/the-updater-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/updater .","title":"Location:"},{"location":"scripts/the-updater-script/#purpose","text":"This script handles Pi-Apps updates, both for apps and for files. Apps do not have version numbers, so updating involves comparing the installation-script of the existing app-folder with the installation-script of the new app-folder.","title":"Purpose:"},{"location":"scripts/the-updater-script/#usage","text":"~/pi-apps/updater gui This will check for updatable apps and files, then will display them in a graphical list, (using yad of course), and will give you the option to update certain items and not others. But that's not all you can do with this script. The updater script supports multiple modes , useful for a variety of situations: - gui - Check for updates and list them graphically. - This is the default mode if you did not specify one. - If you choose to update anything, a terminal will appear to update apps. - gui-yes - Exactly the same as the gui mode, except that the updates are automatically applied in a terminal. - autostarted or onboot - This mode is intended to be run on boot . - First, determine if the update-interval setting allows an update-check today. - If not, the script exits. - Then, make sure that at least one app has been installed . - This is accomplished by checking if there are any files in the data/status folder. A fresh installation of Pi-Apps will not have any files in that folder, because no apps have been installed yet. - If there are no files in that folder, the script will exit. - After that, assuming there are updates available, display a notification in the lower-right corner of the screen. - This notification is designed to not interfere with typing . - If you click Details , you will see the graphical list of updates, just like with the gui mode. - Once updates are complete, another notification will appear to say \"Pi-Apps updates complete.\" - cli - This mode is intended to be run in a terminal . It checks for updates, lists the updates, and prompts for a Y/N answer. - cli-yes - Check for updates, then automatically apply them all. - set-status - Check for updates and then exit. - The list of updatable apps is written to \"${DIRECTORY}/data/update-status/updatable-apps\" , with the DIRECTORY variable being the location of your Pi-Apps folder. (default: /home/pi/pi-apps ) - The list of updatable files is written to \"${DIRECTORY}/data/update-status/updatable-files\" . - The script will exit with code 0 if updates are available, otherwise 1 . - get-status - Check if an update was available the last time set-status was run. - This is based on the length of the updatable-files and updatable-apps files. - Doing it this way allows for an instant update-check - necessary for a gui to run quickly. Nobody wants to wait for an update-check to finish before Pi-Apps will launch. - The script will exit with code 0 if updates are available, otherwise 1 . Updater also supports a fast mode . This is necessary for the Pi-Apps GUI, where you don't want to wait a few seconds after clicking the \"Updates\" category. Using the fast mode will rely on the previous update-check. It won't check for updates, it will simply display them. To use the fast mode: ~/pi-apps/updater gui fast","title":"Usage:"},{"location":"scripts/the-viewlog-script/","text":"Location: On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/viewlog . This file is located in the etc folder because it's one of the smaller scripts. Purpose: View the specified log file in a text editor. Usage: ~/pi-apps/etc/viewlog ~/pi-apps/logs/install-success-Arduino.log Notes: - This script will kill previous instances of itself. - This script does not obey the \"Preferred text editor\" setting. - Why? Viewing a log in geany (the default \"Preferred text editor\" setting) is cumbersome and breaks the whole concept of closing the editor once you click on a new logfile.","title":"The viewlog script"},{"location":"scripts/the-viewlog-script/#location","text":"On a default pi-apps installation, you will find this script at /home/pi/pi-apps/etc/viewlog . This file is located in the etc folder because it's one of the smaller scripts.","title":"Location:"},{"location":"scripts/the-viewlog-script/#purpose","text":"View the specified log file in a text editor.","title":"Purpose:"},{"location":"scripts/the-viewlog-script/#usage","text":"~/pi-apps/etc/viewlog ~/pi-apps/logs/install-success-Arduino.log Notes: - This script will kill previous instances of itself. - This script does not obey the \"Preferred text editor\" setting. - Why? Viewing a log in geany (the default \"Preferred text editor\" setting) is cumbersome and breaks the whole concept of closing the editor once you click on a new logfile.","title":"Usage:"}]}